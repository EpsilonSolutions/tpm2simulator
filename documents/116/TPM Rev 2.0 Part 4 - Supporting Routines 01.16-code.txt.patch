diff --git a/documents/01.16/TPM Rev 2.0 Part 4 - Supporting Routines 01.16-code.txt b/documents/01.16/TPM Rev 2.0 Part 4 - Supporting Routines 01.16-code.txt
index bb0a26b..38d60f2 100644
--- a/documents/01.16/TPM Rev 2.0 Part 4 - Supporting Routines 01.16-code.txt	
+++ b/documents/01.16/TPM Rev 2.0 Part 4 - Supporting Routines 01.16-code.txt	
@@ -41601,11 +41601,7 @@ Level 00 Revision 01.16      Copyright 
 
 410  #define    SHA256_DER                  \
 
-411
-
-     0x30,0x31,0x30,0x0D,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0
-
-     x04,0x20
+411  0x30,0x31,0x30,0x0D,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,0x05,0x00,0x04,0x20
 
      From TCG Algorithm Registry: Table 14 - Defines for SHA384 Hash Values
 
@@ -41617,11 +41613,7 @@ Level 00 Revision 01.16      Copyright 
 
 415  #define    SHA384_DER                  \
 
-416
-
-     0x30,0x41,0x30,0x0D,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0
-
-     x04,0x30
+416  0x30,0x41,0x30,0x0D,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x02,0x05,0x00,0x04,0x30
 
      From TCG Algorithm Registry: Table 15 - Defines for SHA512 Hash Values
 
@@ -41633,11 +41625,7 @@ Level 00 Revision 01.16      Copyright 
 
 420  #define    SHA512_DER                  \
 
-421
-
-     0x30,0x51,0x30,0x0D,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0
-
-     x04,0x40
+421  0x30,0x51,0x30,0x0D,0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x03,0x05,0x00,0x04,0x40
 
      From TCG Algorithm Registry: Table 16 - Defines for SM3_256 Hash Values
 
@@ -41637,11 +41637,7 @@ Level 00 Revision 01.16      Copyright 

 425  #define    SM3_256_DER                    \

-426
-
-     0x30,0x30,0x30,0x0C,0x06,0x08,0x2A,0x81,0x1C,0x81,0x45,0x01,0x83,0x11,0x05,0x00,0x04,0
-
-     x20
+426  0x30,0x30,0x30,0x0C,0x06,0x08,0x2A,0x81,0x1C,0x81,0x45,0x01,0x83,0x11,0x05,0x00,0x04,0x20
 
      From TCG Algorithm Registry: Table 17 - Defines for AES Symmetric Cipher Algorithm Constants
 
@@ -5697,274 +5697,274 @@ Level 00 Revision 01.16      Copyright 
      October 30, 2014                                       Copyright © TCG 2006-2014                               Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                              Trusted Platform Module Library
 
-178      goto          Cleanup;
-
-179
-
-180  //  Number         of  handles            retrieved           from     handle      area      should  be     less     than
-
-181  //  MAX_HANDLE_NUM.
-
-182  pAssert(handleNum               <=        MAX_HANDLE_NUM);
-
-183
-
-184  //  All       handles       in  the       handle          area     are     required      to  reference          TPM-resident
-
-185  //  entities.
-
-186  for(i    =    0;    i  <    handleNum;            i++)
-
-187  {
-
-188      result          =  EntityGetLoadStatus(&handles[i],                                  commandCode);
-
-189      if(result             !=    TPM_RC_SUCCESS)
-
-190      {
-
-191                if(result         ==        TPM_RC_REFERENCE_H0)
-
-192                         result       =     result       +   i;
-
-193                else
-
-194                         result       =     RcSafeAddToResult(result,                      TPM_RC_H        +  g_rcIndex[i]);
-
-195                goto     Cleanup;
-
-196      }
-
-197  }
-
-198
-
-199  //  Authorization               session           handling         for     the     command.
-
-200  if(tag        ==   TPM_ST_SESSIONS)
-
-201  {
-
-202      BYTE                       *sessionBufferStart;//                       address      of  the     session        area   first     byte
-
-203                                                                         //   in     the   input  buffer
-
-204
-
-205      UINT32                     authorizationSize;                      //   number       of  bytes   in     the     session      area
-
-206
-
-207      //        Find     out     session           buffer       size.
-
-208      result          =  UINT32_Unmarshal(&authorizationSize,                                  &buffer,           &size);
-
-209      if(result             !=    TPM_RC_SUCCESS)
-
-210                goto     Cleanup;
-
-211
-
-212      //        Perform       sanity        check        on     the   unmarshaled          value.      If     it  is   smaller     than
-
-213      //        the   smallest           possible           session       or  larger       than   the      remaining        size   of
-
-214      //        the   command,           then       it   is     an   error.       NOTE:    This   check       could      pass  but     the
-
-215      //        session       size       could      still        be   wrong.         That  will   be   determined           after      the
-
-216      //        sessions         are     unmarshaled.
-
-217      if(            authorizationSize                   <   9
-
-218                ||   authorizationSize                   >   (UINT32)         size)
-
-219      {
-
-220                result        =   TPM_RC_SIZE;
-
-221                goto     Cleanup;
-
-222      }
-
-223
-
-224      //        The   sessions,             if     any,     follows       authorizationSize.
-
-225      sessionBufferStart                        =   buffer;
-
-226
-
-227      //        The   parameters            follow          the     session       area.
-
-228      parmBufferStart                    =  sessionBufferStart                    +  authorizationSize;
-
-229
-
-230      //        Any   data       left       over    after        removing         the     authorization           sessions     is
-
-231      //        parameter         data.         If  the      command         does    not   have   parameters,            then  an
-
-232      //        error    will     be        returned         if     the   remaining        size   is   not        zero.  This      is
-
-233      //        checked       later.
-
-234      parmBufferSize                  =     size    -    authorizationSize;
-
-235
-
-236      //        The   actions         of    ParseSessionBuffer()                     are   described          in  the    introduction.
-
-237      result          =  ParseSessionBuffer(commandCode,
-
-238                                                                 handleNum,
-
-239                                                                 handles,
-
-240                                                                 sessionBufferStart,
-
-241                                                                 authorizationSize,
-
-242                                                                 parmBufferStart,
-
-243                                                                 parmBufferSize);
+178           goto          Cleanup;
+          
+179       
+          
+180       //  Number         of  handles            retrieved           from     handle      area      should  be     less     than
+          
+181       //  MAX_HANDLE_NUM.
+          
+182       pAssert(handleNum               <=        MAX_HANDLE_NUM);
+          
+183       
+          
+184       //  All       handles       in  the       handle          area     are     required      to  reference          TPM-resident
+          
+185       //  entities.
+          
+186       for(i    =    0;    i  <    handleNum;            i++)
+          
+187       {
+          
+188           result          =  EntityGetLoadStatus(&handles[i],                                  commandCode);
+          
+189           if(result             !=    TPM_RC_SUCCESS)
+          
+190           {
+          
+191                     if(result         ==        TPM_RC_REFERENCE_H0)
+          
+192                              result       =     result       +   i;
+          
+193                     else
+          
+194                              result       =     RcSafeAddToResult(result,                      TPM_RC_H        +  g_rcIndex[i]);
+          
+195                     goto     Cleanup;
+          
+196           }
+          
+197       }
+          
+198       
+          
+199       //  Authorization               session           handling         for     the     command.
+          
+200       if(tag        ==   TPM_ST_SESSIONS)
+          
+201       {
+          
+202           BYTE                       *sessionBufferStart;//                       address      of  the     session        area   first     byte
+          
+203                                                                              //   in     the   input  buffer
+          
+204       
+          
+205           UINT32                     authorizationSize;                      //   number       of  bytes   in     the     session      area
+          
+206       
+          
+207           //        Find     out     session           buffer       size.
+          
+208           result          =  UINT32_Unmarshal(&authorizationSize,                                  &buffer,           &size);
+          
+209           if(result             !=    TPM_RC_SUCCESS)
+          
+210                     goto     Cleanup;
+          
+211       
+          
+212           //        Perform       sanity        check        on     the   unmarshaled          value.      If     it  is   smaller     than
+          
+213           //        the   smallest           possible           session       or  larger       than   the      remaining        size   of
+          
+214           //        the   command,           then       it   is     an   error.       NOTE:    This   check       could      pass  but     the
+          
+215           //        session       size       could      still        be   wrong.         That  will   be   determined           after      the
+          
+216           //        sessions         are     unmarshaled.
+          
+217           if(            authorizationSize                   <   9
+          
+218                     ||   authorizationSize                   >   (UINT32)         size)
+          
+219           {
+          
+220                     result        =   TPM_RC_SIZE;
+          
+221                     goto     Cleanup;
+          
+222           }
+          
+223       
+          
+224           //        The   sessions,             if     any,     follows       authorizationSize.
+          
+225           sessionBufferStart                        =   buffer;
+          
+226       
+          
+227           //        The   parameters            follow          the     session       area.
+          
+228           parmBufferStart                    =  sessionBufferStart                    +  authorizationSize;
+          
+229       
+          
+230           //        Any   data       left       over    after        removing         the     authorization           sessions     is
+          
+231           //        parameter         data.         If  the      command         does    not   have   parameters,            then  an
+          
+232           //        error    will     be        returned         if     the   remaining        size   is   not        zero.  This      is
+          
+233           //        checked       later.
+          
+234           parmBufferSize                  =     size    -    authorizationSize;
+          
+235       
+          
+236           //        The   actions         of    ParseSessionBuffer()                     are   described          in  the    introduction.
+          
+237           result          =  ParseSessionBuffer(commandCode,
+          
+238                                                                      handleNum,
+          
+239                                                                      handles,
+          
+240                                                                      sessionBufferStart,
+          
+241                                                                      authorizationSize,
+          
+242                                                                      parmBufferStart,
+          
+243                                                                      parmBufferSize);
 
      Family "2.0"                                                   TCG Published                                                              Page 39
 
      Level 00 Revision 01.16                           Copyright © TCG 2006-2014                                                October 30, 2014
      Trusted Platform Module Library                                                                           Part 4: Supporting Routines
 
-244            if(result      !=    TPM_RC_SUCCESS)
-
-245                    goto   Cleanup;
-
-246  }
-
-247  else
-
-248  {
-
-249            //   Whatever       remains        in      the  input     buffer   is    used      for     the  parameters        of  the
-
-250            //   command.
-
-251            parmBufferStart             =  buffer;
-
-252            parmBufferSize           =     size;
-
-253
-
-254            //   The  command        has       no  authorization          sessions.
-
-255            //   If   the  command         requires         authorizations,          then      CheckAuthNoSession()               will
-
-256            //   return    an    error.
-
-257            result    =    CheckAuthNoSession(commandCode,                     handleNum,              handles,
-
-258                                                               parmBufferStart,          parmBufferSize);
-
-259            if(result      !=    TPM_RC_SUCCESS)
-
-260                    goto   Cleanup;
-
-261  }
-
-262
-
-263  //       CommandDispatcher               returns     a    response      handle     buffer       and   a   response      parameter
-
-264  //       buffer     if   it   succeeds.          It  will    also       set  the   parameterSize            field  in   the
-
-265  //       buffer     if   the   tag       is  TPM_RC_SESSIONS.
-
-266  result         =   CommandDispatcher(tag,
-
-267                                                       commandCode,
-
-268                                                       (INT32  *)     &parmBufferSize,
-
-269                                                       parmBufferStart,
-
-270                                                       handles,
-
-271                                                       &resHandleSize,
-
-272                                                       &resParmSize);
-
-273  if(result           !=   TPM_RC_SUCCESS)
-
-274            goto     Cleanup;
-
-275
-
-276  //       Build     the   session         area    at  the     end    of  the  parameter          area.
-
-277  BuildResponseSession(tag,
-
-278                                           commandCode,
-
-279                                           resHandleSize,
-
-280                                           resParmSize,
-
-281                                           &resAuthSize);
-
-282
-
-283  Cleanup:
-
-284  //       This     implementation             loads   an      "evict"    object     to     a  transient      object      slot    in
-
-285  //       RAM   whenever       an   "evict"           object  handle     is   used      in    a  command     so    that  the
-
-286  //       access     to   any   object        is      the  same.     These    temporary          objects     need   to   be
-
-287  //       cleared    from      RAM     whether        the     command    succeeds       or    fails.
-
-288  ObjectCleanupEvict();
-
-289
-
-290  Fail:
-
-291  //       The   response       will       contain     at      least  a   response       header.
-
-292  *responseSize            =    sizeof(TPM_ST)              +  sizeof(UINT32)        +      sizeof(TPM_RC);
-
-293
-
-294  //       If   the   command       completed          successfully,           then  build        the   rest  of    the   response.
-
-295  if(result           ==   TPM_RC_SUCCESS)
-
-296  {
-
-297            //   Outgoing       tag     will       be  the     same   as  the  incoming           tag.
-
-298            resTag    =    tag;
-
-299            //   The  overall        response          will    include    the  handles,           parameters,
-
-300            //   and  authorizations.
-
-301            *responseSize           +=     resHandleSize         +    resParmSize        +     resAuthSize;
-
-302
-
-303            //   Adding    parameter           size    field.
-
-304            if(tag    ==   TPM_ST_SESSIONS)
-
-305                    *responseSize          +=      sizeof(UINT32);
-
-306
-
-307            if(       g_clearOrderly               ==  TRUE
-
-308                 &&   gp.orderlyState              !=  SHUTDOWN_NONE)
-
-309            {
+244                 if(result      !=    TPM_RC_SUCCESS)
+          
+245                         goto   Cleanup;
+          
+246       }
+          
+247       else
+          
+248       {
+          
+249                 //   Whatever       remains        in      the  input     buffer   is    used      for     the  parameters        of  the
+          
+250                 //   command.
+          
+251                 parmBufferStart             =  buffer;
+          
+252                 parmBufferSize           =     size;
+          
+253       
+          
+254                 //   The  command        has       no  authorization          sessions.
+          
+255                 //   If   the  command         requires         authorizations,          then      CheckAuthNoSession()               will
+          
+256                 //   return    an    error.
+          
+257                 result    =    CheckAuthNoSession(commandCode,                     handleNum,              handles,
+          
+258                                                                    parmBufferStart,          parmBufferSize);
+          
+259                 if(result      !=    TPM_RC_SUCCESS)
+          
+260                         goto   Cleanup;
+          
+261       }
+          
+262       
+          
+263       //       CommandDispatcher               returns     a    response      handle     buffer       and   a   response      parameter
+          
+264       //       buffer     if   it   succeeds.          It  will    also       set  the   parameterSize            field  in   the
+          
+265       //       buffer     if   the   tag       is  TPM_RC_SESSIONS.
+          
+266       result         =   CommandDispatcher(tag,
+          
+267                                                            commandCode,
+          
+268                                                            (INT32  *)     &parmBufferSize,
+          
+269                                                            parmBufferStart,
+          
+270                                                            handles,
+          
+271                                                            &resHandleSize,
+          
+272                                                            &resParmSize);
+          
+273       if(result           !=   TPM_RC_SUCCESS)
+          
+274                 goto     Cleanup;
+          
+275       
+          
+276       //       Build     the   session         area    at  the     end    of  the  parameter          area.
+          
+277       BuildResponseSession(tag,
+          
+278                                                commandCode,
+          
+279                                                resHandleSize,
+          
+280                                                resParmSize,
+          
+281                                                &resAuthSize);
+          
+282       
+          
+283       Cleanup:
+          
+284       //       This     implementation             loads   an      "evict"    object     to     a  transient      object      slot    in
+          
+285       //       RAM   whenever       an   "evict"           object  handle     is   used      in    a  command     so    that  the
+          
+286       //       access     to   any   object        is      the  same.     These    temporary          objects     need   to   be
+          
+287       //       cleared    from      RAM     whether        the     command    succeeds       or    fails.
+          
+288       ObjectCleanupEvict();
+          
+289       
+          
+290       Fail:
+          
+291       //       The   response       will       contain     at      least  a   response       header.
+          
+292       *responseSize            =    sizeof(TPM_ST)              +  sizeof(UINT32)        +      sizeof(TPM_RC);
+          
+293       
+          
+294       //       If   the   command       completed          successfully,           then  build        the   rest  of    the   response.
+          
+295       if(result           ==   TPM_RC_SUCCESS)
+          
+296       {
+          
+297                 //   Outgoing       tag     will       be  the     same   as  the  incoming           tag.
+          
+298                 resTag    =    tag;
+          
+299                 //   The  overall        response          will    include    the  handles,           parameters,
+          
+300                 //   and  authorizations.
+          
+301                 *responseSize           +=     resHandleSize         +    resParmSize        +     resAuthSize;
+          
+302       
+          
+303                 //   Adding    parameter           size    field.
+          
+304                 if(tag    ==   TPM_ST_SESSIONS)
+          
+305                         *responseSize          +=      sizeof(UINT32);
+          
+306       
+          
+307                 if(       g_clearOrderly               ==  TRUE
+          
+308                      &&   gp.orderlyState              !=  SHUTDOWN_NONE)
+          
+309                 {
 
      Page 40                                                      TCG Published                                                  Family "2.0"
 
@@ -7294,137 +7294,137 @@ Level 00 Revision 01.16      Copyright 
      Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                          October 30, 2014
      Trusted Platform Module Library                                                                                      Part 4: Supporting Routines
 
-501                   &&   s_encryptSessionIndex                          !=   s_decryptSessionIndex)
-
-502           {
-
-503                   //      Have     to     have        the   nonce         for     the   encrypt       session.
-
-504                   SESSION          *encryptSession
-
-505                                              =     SessionGet(s_sessionHandles[s_encryptSessionIndex]);
-
-506                   nonceEncrypt                  =     &encryptSession->nonceTPM;
-
-507           }
-
-508  }
-
-509
-
-510  //       Continue         with     the         HMAC       processing.
-
-511  session          =    SessionGet(s_sessionHandles[sessionIndex]);
-
-512
-
-513  //       Generate         HMAC     key.
-
-514  MemoryCopy2B(&key.b,                           &session->sessionKey.b,                      sizeof(key.t.buffer));
-
-515
-
-516  //       Check       if   the     session            has   an     associated           handle        and  if   the     associated     entity
-
-517  //       is  the      one     to   which             the  session         is     bound.     If   not,     add  the      authValue     of
-
-518  //       this    entity        to     the         HMAC    key.
-
-519  //       If  the      session         is       bound      to    the      object        or   the  session       is   a   policy  session
-
-520  //       with    no      authValue             required,          do     not     include    the      authValue         in  the  HMAC  key.
-
-521  //       Note:       For   a   policy             session,        its     isBound          attribute      is   CLEARED.
-
-522
-
-523  //       If  the      session         isn't          used     for     authorization,             then     there     is     no  auth  value
-
-524  //       to  add
-
-525  if(s_associatedHandles[sessionIndex]                                            !=     TPM_RH_UNASSIGNED)
-
-526  {
-
-527           //      used     for     auth         so    see   if     this       is     a  policy    session       with     authValue     needed
-
-528           //      or   an   hmac       session             that    is     not     bound
-
-529           if(                      sessionHandleType                      ==     TPM_HT_POLICY_SESSION
-
-530                            &&      session->attributes.isAuthValueNeeded                                   ==   SET
-
-531                   ||               sessionHandleType                      ==     TPM_HT_HMAC_SESSION
-
-532                            &&   !IsSessionBindEntity(s_associatedHandles[sessionIndex],                                                session)
-
-533               )
-
-534           {
-
-535                   //      add   the       authValue            to     the     HMAC      key
-
-536                   pAssert((sizeof(AUTH_VALUE)                                 +   key.t.size)         <=   sizeof(key.t.buffer));
-
-537                   key.t.size              =           key.t.size
-
-538                                                 +     EntityGetAuthValue(s_associatedHandles[sessionIndex],
-
-539                                                                                  (AUTH_VALUE          *)&(key.t.buffer[key.t.size]));
-
-540           }
-
-541  }
-
-542
-
-543     //    if      the     HMAC     key       size     is    0,     a   NULL       string     HMAC     is   allowed
-
-544     if(           key.t.size              ==       0
-
-545               &&  s_inputAuthValues[sessionIndex].t.size                                          ==  0)
-
-546     {
-
-547               hmac->t.size             =     0;
-
-548               return;
-
-549     }
-
-550
-
-551  //       Start       HMAC
-
-552  hmac->t.size               =   CryptStartHMAC2B(session->authHashAlg,                                     &key.b,          &hmacState);
-
-553
-
-554  //       Add     cpHash
-
-555  CryptUpdateDigest2B(&hmacState,                                      &cpHash->b);
-
-556
-
-557  //       Add     nonceCaller
-
-558  CryptUpdateDigest2B(&hmacState,                                      &s_nonceCaller[sessionIndex].b);
-
-559
-
-560  //       Add     nonceTPM
-
-561  CryptUpdateDigest2B(&hmacState,                                      &session->nonceTPM.b);
-
-562
-
-563  //       If      needed,       add       nonceTPM          for       decrypt           session
-
-564  if(nonceDecrypt                   !=     NULL)
-
-565           CryptUpdateDigest2B(&hmacState,                                     &nonceDecrypt->b);
-
-566
+501                         &&   s_encryptSessionIndex                          !=   s_decryptSessionIndex)
+           
+502                 {
+           
+503                         //      Have     to     have        the   nonce         for     the   encrypt       session.
+           
+504                         SESSION          *encryptSession
+           
+505                                                    =     SessionGet(s_sessionHandles[s_encryptSessionIndex]);
+           
+506                         nonceEncrypt                  =     &encryptSession->nonceTPM;
+           
+507                 }
+           
+508        }
+           
+509        
+           
+510        //       Continue         with     the         HMAC       processing.
+           
+511        session          =    SessionGet(s_sessionHandles[sessionIndex]);
+           
+512        
+           
+513        //       Generate         HMAC     key.
+           
+514        MemoryCopy2B(&key.b,                           &session->sessionKey.b,                      sizeof(key.t.buffer));
+           
+515        
+           
+516        //       Check       if   the     session            has   an     associated           handle        and  if   the     associated     entity
+           
+517        //       is  the      one     to   which             the  session         is     bound.     If   not,     add  the      authValue     of
+           
+518        //       this    entity        to     the         HMAC    key.
+           
+519        //       If  the      session         is       bound      to    the      object        or   the  session       is   a   policy  session
+           
+520        //       with    no      authValue             required,          do     not     include    the      authValue         in  the  HMAC  key.
+           
+521        //       Note:       For   a   policy             session,        its     isBound          attribute      is   CLEARED.
+           
+522        
+           
+523        //       If  the      session         isn't          used     for     authorization,             then     there     is     no  auth  value
+           
+524        //       to  add
+           
+525        if(s_associatedHandles[sessionIndex]                                            !=     TPM_RH_UNASSIGNED)
+           
+526        {
+           
+527                 //      used     for     auth         so    see   if     this       is     a  policy    session       with     authValue     needed
+           
+528                 //      or   an   hmac       session             that    is     not     bound
+           
+529                 if(                      sessionHandleType                      ==     TPM_HT_POLICY_SESSION
+           
+530                                  &&      session->attributes.isAuthValueNeeded                                   ==   SET
+           
+531                         ||               sessionHandleType                      ==     TPM_HT_HMAC_SESSION
+           
+532                                  &&   !IsSessionBindEntity(s_associatedHandles[sessionIndex],                                                session)
+           
+533                     )
+           
+534                 {
+           
+535                         //      add   the       authValue            to     the     HMAC      key
+           
+536                         pAssert((sizeof(AUTH_VALUE)                                 +   key.t.size)         <=   sizeof(key.t.buffer));
+           
+537                         key.t.size              =           key.t.size
+           
+538                                                       +     EntityGetAuthValue(s_associatedHandles[sessionIndex],
+           
+539                                                                                        (AUTH_VALUE          *)&(key.t.buffer[key.t.size]));
+           
+540                 }
+           
+541        }
+           
+542        
+           
+543           //    if      the     HMAC     key       size     is    0,     a   NULL       string     HMAC     is   allowed
+           
+544           if(           key.t.size              ==       0
+           
+545                     &&  s_inputAuthValues[sessionIndex].t.size                                          ==  0)
+           
+546           {
+           
+547                     hmac->t.size             =     0;
+           
+548                     return;
+           
+549           }
+           
+550        
+           
+551        //       Start       HMAC
+           
+552        hmac->t.size               =   CryptStartHMAC2B(session->authHashAlg,                                     &key.b,          &hmacState);
+           
+553        
+           
+554        //       Add     cpHash
+           
+555        CryptUpdateDigest2B(&hmacState,                                      &cpHash->b);
+           
+556        
+           
+557        //       Add     nonceCaller
+           
+558        CryptUpdateDigest2B(&hmacState,                                      &s_nonceCaller[sessionIndex].b);
+           
+559        
+           
+560        //       Add     nonceTPM
+           
+561        CryptUpdateDigest2B(&hmacState,                                      &session->nonceTPM.b);
+           
+562        
+           
+563        //       If      needed,       add       nonceTPM          for       decrypt           session
+           
+564        if(nonceDecrypt                   !=     NULL)
+           
+565                 CryptUpdateDigest2B(&hmacState,                                     &nonceDecrypt->b);
+           
+566        
 
      Page 52                                                              TCG Published                                                    Family "2.0"
 
@@ -7655,137 +7655,137 @@ Level 00 Revision 01.16      Copyright 
      October 30, 2014                                    Copyright © TCG 2006-2014                           Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                             Trusted Platform Module Library
 
-646  if(session->timeOut                     !=    0)
-
-647  {
-
-648          //    Cannot          compare         time     if     clock     stop       advancing.      An   TPM_RC_NV_UNAVAILABLE
-
-649          //    or    TPM_RC_NV_RATE                 error       may     be  returned         here.
-
-650          result         =   NvIsAvailable();
-
-651          if(result             !=   TPM_RC_SUCCESS)
-
-652                  return         result;
-
-653
-
-654          if(session->timeOut                   <     go.clock)
-
-655                  return         TPM_RC_EXPIRED;
-
-656  }
-
-657
-
-658  //   If     command           code    is      provided         it   must       match
-
-659  if(session->commandCode                       !=       0)
-
-660  {
-
-661          if(session->commandCode                           !=   commandCode)
-
-662                  return         TPM_RC_POLICY_CC;
-
-663  }
-
-664  else
-
-665  {
-
-666          //    If    command           requires         a   DUP     or   ADMIN      authorization,       the  session    must   have
-
-667          //    command          code     set.
-
-668          AUTH_ROLE                 role     =  CommandAuthRole(commandCode,                         sessionIndex);
-
-669          if(role           ==   AUTH_ADMIN           ||     role     ==     AUTH_DUP)
-
-670                  return         TPM_RC_POLICY_FAIL;
-
-671  }
-
-672  //   Check         command         locality.
-
-673  {
-
-674          BYTE                       sessionLocality[sizeof(TPMA_LOCALITY)];
-
-675          BYTE                      *buffer     =     sessionLocality;
-
-676
-
-677          //    Get      existing         locality           setting         in  canonical     form
-
-678          TPMA_LOCALITY_Marshal(&session->commandLocality,                                           &buffer,    NULL);
-
-679
-
-680          //    See      if     the     locality         has     been     set
-
-681          if(sessionLocality[0]                       !=     0)
-
-682          {
-
-683                  //     If     so,     get     the   current         locality
-
-684                  locality           =  _plat__LocalityGet();
-
-685                  if     (locality           <  5)
-
-686                  {
-
-687                            if(         ((sessionLocality[0]                     &   (1   <<   locality))  ==    0)
-
-688                                    ||  sessionLocality[0]                   >   31)
-
-689                                    return      TPM_RC_LOCALITY;
-
-690                  }
-
-691                  else       if     (locality         >     31)
-
-692                  {
-
-693                            if(sessionLocality[0]                     !=     locality)
-
-694                                    return      TPM_RC_LOCALITY;
-
-695                  }
-
-696                  else
-
-697                  {
-
-698                            //   Could       throw       an     assert       here    but  a    locality   error  is  just
-
-699                            //   as     good.   It       just     means      that,       whatever    the  locality   is,   it   isn't
-
-700                            //   the    locality            requested        so...
-
-701                            return      TPM_RC_LOCALITY;
-
-702                  }
-
-703          }
-
-704  }   //     end     of     locality         check
-
-705
-
-706  //   Check         physical           presence.
-
-707  if(         session->attributes.isPPRequired                                   ==  SET
-
-708       &&     !_plat__PhysicalPresenceAsserted())
-
-709          return         TPM_RC_PP;
-
-710
-
-711  //   Compare           cpHash/nameHash                 if     defined,         or  if   the  command    requires   an   ADMIN  or
+646     if(session->timeOut                     !=    0)
+        
+647     {
+        
+648             //    Cannot          compare         time     if     clock     stop       advancing.      An   TPM_RC_NV_UNAVAILABLE
+        
+649             //    or    TPM_RC_NV_RATE                 error       may     be  returned         here.
+        
+650             result         =   NvIsAvailable();
+        
+651             if(result             !=   TPM_RC_SUCCESS)
+        
+652                     return         result;
+        
+653     
+        
+654             if(session->timeOut                   <     go.clock)
+        
+655                     return         TPM_RC_EXPIRED;
+        
+656     }
+        
+657     
+        
+658     //   If     command           code    is      provided         it   must       match
+        
+659     if(session->commandCode                       !=       0)
+        
+660     {
+        
+661             if(session->commandCode                           !=   commandCode)
+        
+662                     return         TPM_RC_POLICY_CC;
+        
+663     }
+        
+664     else
+        
+665     {
+        
+666             //    If    command           requires         a   DUP     or   ADMIN      authorization,       the  session    must   have
+        
+667             //    command          code     set.
+        
+668             AUTH_ROLE                 role     =  CommandAuthRole(commandCode,                         sessionIndex);
+        
+669             if(role           ==   AUTH_ADMIN           ||     role     ==     AUTH_DUP)
+        
+670                     return         TPM_RC_POLICY_FAIL;
+        
+671     }
+        
+672     //   Check         command         locality.
+        
+673     {
+        
+674             BYTE                       sessionLocality[sizeof(TPMA_LOCALITY)];
+        
+675             BYTE                      *buffer     =     sessionLocality;
+        
+676     
+        
+677             //    Get      existing         locality           setting         in  canonical     form
+        
+678             TPMA_LOCALITY_Marshal(&session->commandLocality,                                           &buffer,    NULL);
+        
+679     
+        
+680             //    See      if     the     locality         has     been     set
+        
+681             if(sessionLocality[0]                       !=     0)
+        
+682             {
+        
+683                     //     If     so,     get     the   current         locality
+        
+684                     locality           =  _plat__LocalityGet();
+        
+685                     if     (locality           <  5)
+        
+686                     {
+        
+687                               if(         ((sessionLocality[0]                     &   (1   <<   locality))  ==    0)
+        
+688                                       ||  sessionLocality[0]                   >   31)
+        
+689                                       return      TPM_RC_LOCALITY;
+        
+690                     }
+        
+691                     else       if     (locality         >     31)
+        
+692                     {
+        
+693                               if(sessionLocality[0]                     !=     locality)
+        
+694                                       return      TPM_RC_LOCALITY;
+        
+695                     }
+        
+696                     else
+        
+697                     {
+        
+698                               //   Could       throw       an     assert       here    but  a    locality   error  is  just
+        
+699                               //   as     good.   It       just     means      that,       whatever    the  locality   is,   it   isn't
+        
+700                               //   the    locality            requested        so...
+        
+701                               return      TPM_RC_LOCALITY;
+        
+702                     }
+        
+703             }
+        
+704     }   //     end     of     locality         check
+        
+705     
+        
+706     //   Check         physical           presence.
+        
+707     if(         session->attributes.isPPRequired                                   ==  SET
+        
+708          &&     !_plat__PhysicalPresenceAsserted())
+        
+709             return         TPM_RC_PP;
+        
+710     
+        
+711     //   Compare           cpHash/nameHash                 if     defined,         or  if   the  command    requires   an   ADMIN  or
 
      Family "2.0"                                                    TCG Published                                                  Page 55
 
@@ -8798,137 +8798,137 @@ Level 00 Revision 01.16      Copyright 
       Level 00 Revision 01.16                              Copyright © TCG 2006-2014                                        October 30, 2014
       Trusted Platform Module Library                                                                                       Part 4: Supporting Routines
 
-1152                 //   Note:        for     all       the   TPM     2.0    commands,              handles      requiring
-
-1153                 //   authorization                  come     first       in   a   command          input.
-
-1154                 if(i     >  (s_sessionNum                 -  1))
-
-1155                         return       TPM_RC_AUTH_MISSING;
-
-1156
-
-1157                 //   Record          the     handle       associated             with    the       authorization           session
-
-1158                 s_associatedHandles[i]                       =    handles[i];
-
-1159           }
-
-1160  }
-
-1161
-
-1162  //       Consistency       checks           are    done     first       to      avoid       auth      failure    when      the    command
-
-1163  //       will  not     be  executed               anyway.
-
-1164  for(sessionIndex                 =  0;      sessionIndex             <  s_sessionNum;                 sessionIndex++)
-
-1165  {
-
-1166           //    PW  session          must       be  an    authorization                 session
-
-1167           if(s_sessionHandles[sessionIndex]                                  ==   TPM_RS_PW            )
-
-1168           {
-
-1169                 if(s_associatedHandles[sessionIndex]                                     ==     TPM_RH_UNASSIGNED)
-
-1170                         return       TPM_RC_HANDLE                +   g_rcIndex[sessionIndex];
-
-1171           }
-
-1172           else
-
-1173           {
-
-1174                 session        =     SessionGet(s_sessionHandles[sessionIndex]);
-
-1175
-
-1176                 //   A   trial       session        can      not      appear         in  session          area,   because          it  cannot
-
-1177                 //   be     used     for        authorization,               audit       or     encrypt/decrypt.
-
-1178                 if(session->attributes.isTrialPolicy                                     ==     SET)
-
-1179                         return       TPM_RC_ATTRIBUTES                   +    TPM_RC_S          +   g_rcIndex[sessionIndex];
-
-1180
-
-1181                 //   See    if       the     session         is   bound       to     a   DA     protected         entity
-
-1182                 //   NOTE:        Since         a   policy       session         is     never      bound,      a  policy       is  still
-
-1183                 //   usable          even       if  the      object      is      DA     protected         and     the  TPM     is  in
-
-1184                 //   lockout.
-
-1185                 if(session->attributes.isDaBound                                  ==     SET)
-
-1186                 {
-
-1187                         result       =    CheckLockedOut(session->attributes.isLockoutBound                                            ==  SET);
-
-1188                         if(result            !=     TPM_RC_SUCCESS)
-
-1189                                return           result;
-
-1190                 }
-
-1191                 //   If     the      current        cpHash        is     the     right       one,      don't      re-compute.
-
-1192                 if(cpHashAlg              !=       session->authHashAlg)                        //     different       so   compute
-
-1193                 {
-
-1194                         cpHashAlg            =     session->authHashAlg;                        //     save    this    new     algID
-
-1195                         ComputeCpHash(session->authHashAlg,                                     commandCode,           handleNum,
-
-1196                                                     handles,          parmBufferSize,                  parmBufferStart,
-
-1197                                                     &cpHash,          &nameHash);
-
-1198                 }
-
-1199                 //   If     this     session        is       for     auditing,           save      the    cpHash.
-
-1200                 if(s_attributes[sessionIndex].audit)
-
-1201                         s_cpHashForAudit                  =  cpHash;
-
-1202           }
-
-1203
-
-1204           //    if  the     session          has    an    associated             handle,        check     the     auth
-
-1205           if(s_associatedHandles[sessionIndex]                                    !=     TPM_RH_UNASSIGNED)
-
-1206           {
-
-1207                 result      =     CheckAuthSession(commandCode,                                 sessionIndex,
-
-1208                                                                      &cpHash,           &nameHash);
-
-1209                 if(result            !=   TPM_RC_SUCCESS)
-
-1210                         return       RcSafeAddToResult(result,
-
-1211                                                                          TPM_RC_S            +  g_rcIndex[sessionIndex]);
-
-1212           }
-
-1213           else
-
-1214           {
-
-1215                 //   a   session          that      is    not     for    authorization                 must    either      be  encrypt,
-
-1216                 //   decrypt,            or     audit
-
-1217                 if(            s_attributes[sessionIndex].audit                                    ==     CLEAR
+1152                     //   Note:        for     all       the   TPM     2.0    commands,              handles      requiring
+          
+1153                     //   authorization                  come     first       in   a   command          input.
+          
+1154                     if(i     >  (s_sessionNum                 -  1))
+          
+1155                             return       TPM_RC_AUTH_MISSING;
+          
+1156      
+          
+1157                     //   Record          the     handle       associated             with    the       authorization           session
+          
+1158                     s_associatedHandles[i]                       =    handles[i];
+          
+1159               }
+          
+1160      }
+          
+1161      
+          
+1162      //       Consistency       checks           are    done     first       to      avoid       auth      failure    when      the    command
+          
+1163      //       will  not     be  executed               anyway.
+          
+1164      for(sessionIndex                 =  0;      sessionIndex             <  s_sessionNum;                 sessionIndex++)
+          
+1165      {
+          
+1166               //    PW  session          must       be  an    authorization                 session
+          
+1167               if(s_sessionHandles[sessionIndex]                                  ==   TPM_RS_PW            )
+          
+1168               {
+          
+1169                     if(s_associatedHandles[sessionIndex]                                     ==     TPM_RH_UNASSIGNED)
+          
+1170                             return       TPM_RC_HANDLE                +   g_rcIndex[sessionIndex];
+          
+1171               }
+          
+1172               else
+          
+1173               {
+          
+1174                     session        =     SessionGet(s_sessionHandles[sessionIndex]);
+          
+1175      
+          
+1176                     //   A   trial       session        can      not      appear         in  session          area,   because          it  cannot
+          
+1177                     //   be     used     for        authorization,               audit       or     encrypt/decrypt.
+          
+1178                     if(session->attributes.isTrialPolicy                                     ==     SET)
+          
+1179                             return       TPM_RC_ATTRIBUTES                   +    TPM_RC_S          +   g_rcIndex[sessionIndex];
+          
+1180      
+          
+1181                     //   See    if       the     session         is   bound       to     a   DA     protected         entity
+          
+1182                     //   NOTE:        Since         a   policy       session         is     never      bound,      a  policy       is  still
+          
+1183                     //   usable          even       if  the      object      is      DA     protected         and     the  TPM     is  in
+          
+1184                     //   lockout.
+          
+1185                     if(session->attributes.isDaBound                                  ==     SET)
+          
+1186                     {
+          
+1187                             result       =    CheckLockedOut(session->attributes.isLockoutBound                                            ==  SET);
+          
+1188                             if(result            !=     TPM_RC_SUCCESS)
+          
+1189                                    return           result;
+          
+1190                     }
+          
+1191                     //   If     the      current        cpHash        is     the     right       one,      don't      re-compute.
+          
+1192                     if(cpHashAlg              !=       session->authHashAlg)                        //     different       so   compute
+          
+1193                     {
+          
+1194                             cpHashAlg            =     session->authHashAlg;                        //     save    this    new     algID
+          
+1195                             ComputeCpHash(session->authHashAlg,                                     commandCode,           handleNum,
+          
+1196                                                         handles,          parmBufferSize,                  parmBufferStart,
+          
+1197                                                         &cpHash,          &nameHash);
+          
+1198                     }
+          
+1199                     //   If     this     session        is       for     auditing,           save      the    cpHash.
+          
+1200                     if(s_attributes[sessionIndex].audit)
+          
+1201                             s_cpHashForAudit                  =  cpHash;
+          
+1202               }
+          
+1203      
+          
+1204               //    if  the     session          has    an    associated             handle,        check     the     auth
+          
+1205               if(s_associatedHandles[sessionIndex]                                    !=     TPM_RH_UNASSIGNED)
+          
+1206               {
+          
+1207                     result      =     CheckAuthSession(commandCode,                                 sessionIndex,
+          
+1208                                                                          &cpHash,           &nameHash);
+          
+1209                     if(result            !=   TPM_RC_SUCCESS)
+          
+1210                             return       RcSafeAddToResult(result,
+          
+1211                                                                              TPM_RC_S            +  g_rcIndex[sessionIndex]);
+          
+1212               }
+          
+1213               else
+          
+1214               {
+          
+1215                     //   a   session          that      is    not     for    authorization                 must    either      be  encrypt,
+          
+1216                     //   decrypt,            or     audit
+          
+1217                     if(            s_attributes[sessionIndex].audit                                    ==     CLEAR
 
       Page 64                                                         TCG Published                                                         Family "2.0"
 
@@ -10034,137 +10034,137 @@ Level 00 Revision 01.16      Copyright 
       Level 00 Revision 01.16                            Copyright © TCG 2006-2014                                  October        30, 2014
       Trusted Platform Module Library                                                                                Part 4: Supporting Routines
 
-1709  {
-
-1710              UpdateTPMNonce(MAX_SESSION_NUM,                          responseNonces);
-
-1711
-
-1712              //  Encrypt         first     parameter         if    applicable.      Parameter            encryption         should
-
-1713              //  happen          after     nonce      update     and   before      any   rpHash         is   computed.
-
-1714              //  If    the       encrypt       session     is    associated        with     a   handle,         the   authValue     of
-
-1715              //  this     handle        will     be   concatenated          with   sessionAuth              to  generate
-
-1716              //  encryption            key,    no     matter     if   the   handle      is     the     session       bound  entity
-
-1717              //  or    not.      The    authValue        is    added   to   sessionAuth             only     when     the   authValue
-
-1718              //  is    available.
-
-1719              if(s_encryptSessionIndex                    !=    UNDEFINED_INDEX)
-
-1720              {
-
-1721                    UINT32                        size;
-
-1722                    TPM2B_AUTH                    extraKey;
-
-1723
-
-1724                    //     Get    size      of  the    leading        size   field
-
-1725                    if(           s_associatedHandles[s_encryptSessionIndex]                                 !=  TPM_RH_UNASSIGNED
-
-1726                           &&     IsAuthValueAvailable(s_associatedHandles[s_encryptSessionIndex],
-
-1727                                                                      commandCode,        s_encryptSessionIndex)
-
-1728                        )
-
-1729                    {
-
-1730                           extraKey.b.size             =
-
-1731                                     EntityGetAuthValue(s_associatedHandles[s_encryptSessionIndex],
-
-1732                                                                      &extraKey.t.buffer);
-
-1733                    }
-
-1734                    else
-
-1735                    {
-
-1736                           extraKey.b.size             =    0;
-
-1737                    }
-
-1738                    size       =  EncryptSize(commandCode);
-
-1739                    CryptParameterEncryption(s_sessionHandles[s_encryptSessionIndex],
-
-1740                                                                  &s_nonceCaller[s_encryptSessionIndex].b,
-
-1741                                                                  (UINT16)size,
-
-1742                                                                  &extraKey,
-
-1743                                                                  resParmBuffer);
-
-1744
-
-1745              }
-
-1746
-
-1747  }
-
-1748  //       Audit       session       should       be   updated        first  regardless             of   the     tag.
-
-1749  //       A     command       with     no  session       may     trigger    a  change          of   the     exclusivity     state.
-
-1750  UpdateAuditSessionStatus(commandCode,                                 resParmSize,             resParmBuffer);
-
-1751
-
-1752  //       Audit       command.
-
-1753  CommandAudit(commandCode,                            resParmSize,         resParmBuffer);
-
-1754
-
-1755  //       Process         command       with     sessions.
-
-1756  if(tag          ==    TPM_ST_SESSIONS)
-
-1757  {
-
-1758              UINT32                        i;
-
-1759              BYTE                          *buffer;
-
-1760              TPM2B_DIGEST                  responseAuths[MAX_SESSION_NUM];
-
-1761
-
-1762              pAssert(s_sessionNum                  >  0);
-
-1763
-
-1764              //  Iterate         over      each    session       in   the   command      session         area,       and   create
-
-1765              //  corresponding             sessions        for     response.
-
-1766              for(i     =  0;     i  <   s_sessionNum;            i++)
-
-1767              {
-
-1768                    BuildSingleResponseAuth(
-
-1769                                                                i,
-
-1770                                                                commandCode,
-
-1771                                                                resParmSize,
-
-1772                                                                resParmBuffer,
-
-1773                                                                &responseAuths[i]);
-
-1774                    //     Make      sure   that       continueSession          is  SET      on     any   Password         session.
+1709        {
+            
+1710                    UpdateTPMNonce(MAX_SESSION_NUM,                          responseNonces);
+            
+1711        
+            
+1712                    //  Encrypt         first     parameter         if    applicable.      Parameter            encryption         should
+            
+1713                    //  happen          after     nonce      update     and   before      any   rpHash         is   computed.
+            
+1714                    //  If    the       encrypt       session     is    associated        with     a   handle,         the   authValue     of
+            
+1715                    //  this     handle        will     be   concatenated          with   sessionAuth              to  generate
+            
+1716                    //  encryption            key,    no     matter     if   the   handle      is     the     session       bound  entity
+            
+1717                    //  or    not.      The    authValue        is    added   to   sessionAuth             only     when     the   authValue
+            
+1718                    //  is    available.
+            
+1719                    if(s_encryptSessionIndex                    !=    UNDEFINED_INDEX)
+            
+1720                    {
+            
+1721                          UINT32                        size;
+            
+1722                          TPM2B_AUTH                    extraKey;
+            
+1723        
+            
+1724                          //     Get    size      of  the    leading        size   field
+            
+1725                          if(           s_associatedHandles[s_encryptSessionIndex]                                 !=  TPM_RH_UNASSIGNED
+            
+1726                                 &&     IsAuthValueAvailable(s_associatedHandles[s_encryptSessionIndex],
+            
+1727                                                                            commandCode,        s_encryptSessionIndex)
+            
+1728                              )
+            
+1729                          {
+            
+1730                                 extraKey.b.size             =
+            
+1731                                           EntityGetAuthValue(s_associatedHandles[s_encryptSessionIndex],
+            
+1732                                                                            &extraKey.t.buffer);
+            
+1733                          }
+            
+1734                          else
+            
+1735                          {
+            
+1736                                 extraKey.b.size             =    0;
+            
+1737                          }
+            
+1738                          size       =  EncryptSize(commandCode);
+            
+1739                          CryptParameterEncryption(s_sessionHandles[s_encryptSessionIndex],
+            
+1740                                                                        &s_nonceCaller[s_encryptSessionIndex].b,
+            
+1741                                                                        (UINT16)size,
+            
+1742                                                                        &extraKey,
+            
+1743                                                                        resParmBuffer);
+            
+1744        
+            
+1745                    }
+            
+1746        
+            
+1747        }
+            
+1748        //       Audit       session       should       be   updated        first  regardless             of   the     tag.
+            
+1749        //       A     command       with     no  session       may     trigger    a  change          of   the     exclusivity     state.
+            
+1750        UpdateAuditSessionStatus(commandCode,                                 resParmSize,             resParmBuffer);
+            
+1751        
+            
+1752        //       Audit       command.
+            
+1753        CommandAudit(commandCode,                            resParmSize,         resParmBuffer);
+            
+1754        
+            
+1755        //       Process         command       with     sessions.
+            
+1756        if(tag          ==    TPM_ST_SESSIONS)
+            
+1757        {
+            
+1758                    UINT32                        i;
+            
+1759                    BYTE                          *buffer;
+            
+1760                    TPM2B_DIGEST                  responseAuths[MAX_SESSION_NUM];
+            
+1761        
+            
+1762                    pAssert(s_sessionNum                  >  0);
+            
+1763        
+            
+1764                    //  Iterate         over      each    session       in   the   command      session         area,       and   create
+            
+1765                    //  corresponding             sessions        for     response.
+            
+1766                    for(i     =  0;     i  <   s_sessionNum;            i++)
+            
+1767                    {
+            
+1768                          BuildSingleResponseAuth(
+            
+1769                                                                      i,
+            
+1770                                                                      commandCode,
+            
+1771                                                                      resParmSize,
+            
+1772                                                                      resParmBuffer,
+            
+1773                                                                      &responseAuths[i]);
+            
+1774                          //     Make      sure   that       continueSession          is  SET      on     any   Password         session.
 
       Page 74                                                       TCG Published                                                       Family "2.0"
 
@@ -13610,137 +13610,137 @@ Level 00 Revision 01.16      Copyright 
      Level 00 Revision 01.16                     Copyright © TCG 2006-2014                                          October 30, 2014
       Trusted Platform Module Library                                                                                Part 4: Supporting Routines
 
-938   pAssert(symDef              !=  NULL       &&     innerSymKey             !=  NULL);
-
-939
-
-940   //  Starting      of        sensitive          data       without         wrappers
-
-941   sensitiveData            =  outPrivate->t.buffer;
-
-942
-
-943   //  Find     out  if        inner      wrap       is     required
-
-944   if(symDef->algorithm                   !=     TPM_ALG_NULL)
-
-945   {
-
-946       doInnerWrap             =   TRUE;
-
-947       //    Use     self      nameAlg           as  inner          hash     algorithm
-
-948       innerHash            =  nameAlg;
-
-949       //    Adjust         sensitive            data       pointer
-
-950       sensitiveData               +=     sizeof(UINT16)                 +   CryptGetHashDigestSize(innerHash);
-
-951   }
-
-952
-
-953   //  Find     out  if        outer      wrap       is     required
-
-954   if(seed->t.size             !=    0)
-
-955   {
-
-956       doOuterWrap             =   TRUE;
-
-957       //    Use     parent        nameAlg           as     outer      hash      algorithm
-
-958       outerHash            =  ObjectGetNameAlg(parentHandle);
-
-959       //    Adjust         sensitive            data       pointer
-
-960       sensitiveData               +=     sizeof(UINT16)                 +   CryptGetHashDigestSize(outerHash);
-
-961   }
-
-962
-
-963   //  Marshal       sensitive            area,      leaving           the      leading  2  bytes        for   size
-
-964   buffer    =  sensitiveData                 +   sizeof(UINT16);
-
-965   dataSize     =    TPMT_SENSITIVE_Marshal(sensitive,                                  &buffer,    NULL);
-
-966
-
-967   //  Adding       size       before      the       data     area
-
-968   buffer    =  sensitiveData;
-
-969   UINT16_Marshal(&dataSize,                         &buffer,          NULL);
-
-970
-
-971   //  Adjust       the     dataSize          to     include           the   size   field
-
-972   dataSize     +=   sizeof(UINT16);
-
-973
-
-974   //  Apply    inner          wrap    for       duplication             blob.      It   includes        both     integrity      and
-
-975   //  encryption
-
-976   if(doInnerWrap)
-
-977   {
-
-978       BYTE                            *innerBuffer                 =  NULL;
-
-979       BOOL                            symKeyInput               =     TRUE;
-
-980       innerBuffer             =   outPrivate->t.buffer;
-
-981       //    Skip    outer         integrity             space
-
-982       if(doOuterWrap)
-
-983                innerBuffer            +=     sizeof(UINT16)                 +   CryptGetHashDigestSize(outerHash);
-
-984       dataSize          =     ProduceInnerIntegrity(name,                          innerHash,      dataSize,
-
-985                                                                            innerBuffer);
-
-986
-
-987       //    Generate          inner       encryption               key     if   needed
-
-988       if(innerSymKey->t.size                        ==      0)
-
-989       {
-
-990                innerSymKey->t.size                      =   (symDef->keyBits.sym                +  7)   /    8;
-
-991                CryptGenerateRandom(innerSymKey->t.size,                                    innerSymKey->t.buffer);
-
-992
-
-993                //   TPM       generates          symmetric            encryption.          Set     the  flag        to  FALSE
-
-994                symKeyInput            =   FALSE;
-
-995       }
-
-996       else
-
-997       {
-
-998                //   assume        the     input         key     size       should  matches         the  symmetric          definition
-
-999                pAssert(innerSymKey->t.size                              ==     (symDef->keyBits.sym              +  7)  /  8);
-
-1000
-
-1001      }
-
-1002
-
-1003      //    Encrypt           inner      buffer         in   place
+938        pAssert(symDef              !=  NULL       &&     innerSymKey             !=  NULL);
+           
+939        
+           
+940        //  Starting      of        sensitive          data       without         wrappers
+           
+941        sensitiveData            =  outPrivate->t.buffer;
+           
+942        
+           
+943        //  Find     out  if        inner      wrap       is     required
+           
+944        if(symDef->algorithm                   !=     TPM_ALG_NULL)
+           
+945        {
+           
+946            doInnerWrap             =   TRUE;
+           
+947            //    Use     self      nameAlg           as  inner          hash     algorithm
+           
+948            innerHash            =  nameAlg;
+           
+949            //    Adjust         sensitive            data       pointer
+           
+950            sensitiveData               +=     sizeof(UINT16)                 +   CryptGetHashDigestSize(innerHash);
+           
+951        }
+           
+952        
+           
+953        //  Find     out  if        outer      wrap       is     required
+           
+954        if(seed->t.size             !=    0)
+           
+955        {
+           
+956            doOuterWrap             =   TRUE;
+           
+957            //    Use     parent        nameAlg           as     outer      hash      algorithm
+           
+958            outerHash            =  ObjectGetNameAlg(parentHandle);
+           
+959            //    Adjust         sensitive            data       pointer
+           
+960            sensitiveData               +=     sizeof(UINT16)                 +   CryptGetHashDigestSize(outerHash);
+           
+961        }
+           
+962        
+           
+963        //  Marshal       sensitive            area,      leaving           the      leading  2  bytes        for   size
+           
+964        buffer    =  sensitiveData                 +   sizeof(UINT16);
+           
+965        dataSize     =    TPMT_SENSITIVE_Marshal(sensitive,                                  &buffer,    NULL);
+           
+966        
+           
+967        //  Adding       size       before      the       data     area
+           
+968        buffer    =  sensitiveData;
+           
+969        UINT16_Marshal(&dataSize,                         &buffer,          NULL);
+           
+970        
+           
+971        //  Adjust       the     dataSize          to     include           the   size   field
+           
+972        dataSize     +=   sizeof(UINT16);
+           
+973        
+           
+974        //  Apply    inner          wrap    for       duplication             blob.      It   includes        both     integrity      and
+           
+975        //  encryption
+           
+976        if(doInnerWrap)
+           
+977        {
+           
+978            BYTE                            *innerBuffer                 =  NULL;
+           
+979            BOOL                            symKeyInput               =     TRUE;
+           
+980            innerBuffer             =   outPrivate->t.buffer;
+           
+981            //    Skip    outer         integrity             space
+           
+982            if(doOuterWrap)
+           
+983                     innerBuffer            +=     sizeof(UINT16)                 +   CryptGetHashDigestSize(outerHash);
+           
+984            dataSize          =     ProduceInnerIntegrity(name,                          innerHash,      dataSize,
+           
+985                                                                                 innerBuffer);
+           
+986        
+           
+987            //    Generate          inner       encryption               key     if   needed
+           
+988            if(innerSymKey->t.size                        ==      0)
+           
+989            {
+           
+990                     innerSymKey->t.size                      =   (symDef->keyBits.sym                +  7)   /    8;
+           
+991                     CryptGenerateRandom(innerSymKey->t.size,                                    innerSymKey->t.buffer);
+           
+992        
+           
+993                     //   TPM       generates          symmetric            encryption.          Set     the  flag        to  FALSE
+           
+994                     symKeyInput            =   FALSE;
+           
+995            }
+           
+996            else
+           
+997            {
+           
+998                     //   assume        the     input         key     size       should  matches         the  symmetric          definition
+           
+999                     pAssert(innerSymKey->t.size                              ==     (symDef->keyBits.sym              +  7)  /  8);
+           
+1000       
+           
+1001           }
+           
+1002       
+           
+1003           //    Encrypt           inner      buffer         in   place
 
       Page 104                                                      TCG Published                                                   Family "2.0"
 
@@ -13862,137 +13862,137 @@ Level 00 Revision 01.16      Copyright 
       Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                         October 30, 2014
       Trusted Platform Module Library                                                                          Part 4: Supporting Routines
 
-1049  BYTE                            *buffer;
-
-1050  INT32                           size;
-
-1051  BYTE                            *sensitiveData;                //  pointer      to  the  sensitive       data
-
-1052  UINT16                          dataSize;
-
-1053  UINT16                          dataSizeInput;
-
-1054
-
-1055  //  Make        sure    that        name     is  provided
-
-1056  pAssert(name            !=      NULL    &&   name->t.size             !=   0);
-
-1057
-
-1058  //  Make        sure    symDef          and  innerSymKey           are     not   NULL
-
-1059  pAssert(symDef                 !=   NULL     &&  innerSymKey          !=   NULL);
-
-1060
-
-1061  //  Starting            of     sensitive         data
-
-1062  sensitiveData               =   inPrivate->t.buffer;
-
-1063  dataSize        =    inPrivate->t.size;
-
-1064
-
-1065  //  Find        out     if     outer    wrap     is    applied
-
-1066  if(seed->t.size                 !=  0)
-
-1067  {
-
-1068        TPMI_ALG_HASH                     outerHash        =     TPM_ALG_NULL;
-
-1069
-
-1070        //     Use     parent         nameAlg      as    outer       hash    algorithm
-
-1071        outerHash             =   ObjectGetNameAlg(parentHandle);
-
-1072        result         =  UnwrapOuter(parentHandle,                         name,     outerHash,  seed,       FALSE,
-
-1073                                                   dataSize,         sensitiveData);
-
-1074        if(result             !=     TPM_RC_SUCCESS)
-
-1075                  return         result;
-
-1076
-
-1077        //     Adjust         sensitive        data      pointer        and  size
-
-1078        sensitiveData                 +=  sizeof(UINT16)             +  CryptGetHashDigestSize(outerHash);
-
-1079        dataSize          -=      sizeof(UINT16)              +  CryptGetHashDigestSize(outerHash);
-
-1080  }
-
-1081  //  Find        out     if     inner    wrap     is    applied
-
-1082  if(symDef->algorithm                    !=   TPM_ALG_NULL)
-
-1083  {
-
-1084        TPMI_ALG_HASH                     innerHash        =     TPM_ALG_NULL;
-
-1085
-
-1086        //     assume         the     input    key     size      should      matches     the  symmetric       definition
-
-1087        pAssert(innerSymKey->t.size                              ==  (symDef->keyBits.sym         +    7)  /  8);
-
-1088
-
-1089        //     Decrypt           inner    buffer       in     place
-
-1090        CryptSymmetricDecrypt(sensitiveData,                                 symDef->algorithm,
-
-1091                                                   symDef->keyBits.sym,               TPM_ALG_CFB,
-
-1092                                                   innerSymKey->t.buffer,                  NULL,  dataSize,
-
-1093                                                   sensitiveData);
-
-1094
-
-1095        //     Use     self       nameAlg      as   inner        hash   algorithm
-
-1096        innerHash             =   nameAlg;
-
-1097
-
-1098        //     Check      inner       integrity
-
-1099        result         =  CheckInnerIntegrity(name,                         innerHash,     dataSize,       sensitiveData);
-
-1100        if(result             !=     TPM_RC_SUCCESS)
-
-1101                  return         result;
-
-1102
-
-1103        //     Adjust         sensitive        data      pointer        and  size
-
-1104        sensitiveData                 +=  sizeof(UINT16)             +  CryptGetHashDigestSize(innerHash);
-
-1105        dataSize          -=      sizeof(UINT16)              +  CryptGetHashDigestSize(innerHash);
-
-1106  }
-
-1107
-
-1108  //  Unmarshal           input       data     size
-
-1109  buffer       =  sensitiveData;
-
-1110  size      =  (INT32)           dataSize;
-
-1111  result       =  UINT16_Unmarshal(&dataSizeInput,                               &buffer,     &size);
-
-1112  if(result          ==   TPM_RC_SUCCESS)
-
-1113  {
-
-1114        if((dataSizeInput                   +  sizeof(UINT16))               !=   dataSize)
+1049        BYTE                            *buffer;
+            
+1050        INT32                           size;
+            
+1051        BYTE                            *sensitiveData;                //  pointer      to  the  sensitive       data
+            
+1052        UINT16                          dataSize;
+            
+1053        UINT16                          dataSizeInput;
+            
+1054        
+            
+1055        //  Make        sure    that        name     is  provided
+            
+1056        pAssert(name            !=      NULL    &&   name->t.size             !=   0);
+            
+1057        
+            
+1058        //  Make        sure    symDef          and  innerSymKey           are     not   NULL
+            
+1059        pAssert(symDef                 !=   NULL     &&  innerSymKey          !=   NULL);
+            
+1060        
+            
+1061        //  Starting            of     sensitive         data
+            
+1062        sensitiveData               =   inPrivate->t.buffer;
+            
+1063        dataSize        =    inPrivate->t.size;
+            
+1064        
+            
+1065        //  Find        out     if     outer    wrap     is    applied
+            
+1066        if(seed->t.size                 !=  0)
+            
+1067        {
+            
+1068              TPMI_ALG_HASH                     outerHash        =     TPM_ALG_NULL;
+            
+1069        
+            
+1070              //     Use     parent         nameAlg      as    outer       hash    algorithm
+            
+1071              outerHash             =   ObjectGetNameAlg(parentHandle);
+            
+1072              result         =  UnwrapOuter(parentHandle,                         name,     outerHash,  seed,       FALSE,
+            
+1073                                                         dataSize,         sensitiveData);
+            
+1074              if(result             !=     TPM_RC_SUCCESS)
+            
+1075                        return         result;
+            
+1076        
+            
+1077              //     Adjust         sensitive        data      pointer        and  size
+            
+1078              sensitiveData                 +=  sizeof(UINT16)             +  CryptGetHashDigestSize(outerHash);
+            
+1079              dataSize          -=      sizeof(UINT16)              +  CryptGetHashDigestSize(outerHash);
+            
+1080        }
+            
+1081        //  Find        out     if     inner    wrap     is    applied
+            
+1082        if(symDef->algorithm                    !=   TPM_ALG_NULL)
+            
+1083        {
+            
+1084              TPMI_ALG_HASH                     innerHash        =     TPM_ALG_NULL;
+            
+1085        
+            
+1086              //     assume         the     input    key     size      should      matches     the  symmetric       definition
+            
+1087              pAssert(innerSymKey->t.size                              ==  (symDef->keyBits.sym         +    7)  /  8);
+            
+1088        
+            
+1089              //     Decrypt           inner    buffer       in     place
+            
+1090              CryptSymmetricDecrypt(sensitiveData,                                 symDef->algorithm,
+            
+1091                                                         symDef->keyBits.sym,               TPM_ALG_CFB,
+            
+1092                                                         innerSymKey->t.buffer,                  NULL,  dataSize,
+            
+1093                                                         sensitiveData);
+            
+1094        
+            
+1095              //     Use     self       nameAlg      as   inner        hash   algorithm
+            
+1096              innerHash             =   nameAlg;
+            
+1097        
+            
+1098              //     Check      inner       integrity
+            
+1099              result         =  CheckInnerIntegrity(name,                         innerHash,     dataSize,       sensitiveData);
+            
+1100              if(result             !=     TPM_RC_SUCCESS)
+            
+1101                        return         result;
+            
+1102        
+            
+1103              //     Adjust         sensitive        data      pointer        and  size
+            
+1104              sensitiveData                 +=  sizeof(UINT16)             +  CryptGetHashDigestSize(innerHash);
+            
+1105              dataSize          -=      sizeof(UINT16)              +  CryptGetHashDigestSize(innerHash);
+            
+1106        }
+            
+1107        
+            
+1108        //  Unmarshal           input       data     size
+            
+1109        buffer       =  sensitiveData;
+            
+1110        size      =  (INT32)           dataSize;
+            
+1111        result       =  UINT16_Unmarshal(&dataSizeInput,                               &buffer,     &size);
+            
+1112        if(result          ==   TPM_RC_SUCCESS)
+            
+1113        {
+            
+1114              if((dataSizeInput                   +  sizeof(UINT16))               !=   dataSize)
 
       Page 106                                                       TCG Published                                            Family "2.0"
 
@@ -24608,137 +24608,137 @@ Level 00 Revision 01.16      Copyright 
      Level 00 Revision 01.16                       Copyright © TCG 2006-2014                                    October 30, 2014
      Trusted Platform Module Library                                                                                Part 4: Supporting Routines
 
-235         //  Is      this    available?
-
-236         if(s_sessions[slotIndex].occupied                                   ==   FALSE)
-
-237         {
-
-238                 session        =   &s_sessions[slotIndex].session;
-
-239                 break;
-
-240         }
-
-241  }
-
-242  //  if     no  spot        found,        then       this   is       an  internal           error
-
-243  pAssert        (slotIndex            <   MAX_LOADED_SESSIONS);
-
-244
-
-245  //  Call       context        ID     function         to   get      a   handle.            TPM_RC_SESSION_HANDLE          may  be
-
-246  //  returned           from      ContextIdHandelAssign()
-
-247  result     =   ContextIdSessionCreate(sessionHandle,                                       slotIndex);
-
-248  if(result          !=  TPM_RC_SUCCESS)
-
-249         return      result;
-
-250
-
-251  //***      Only    return         from       this     point         on  is     TPM_RC_SUCCESS
-
-252
-
-253  //  Can    now     indicate             that     the   session          array         entry   is  occupied.
-
-254  s_freeSessionSlots--;
-
-255  s_sessions[slotIndex].occupied                             =     TRUE;
-
-256
-
-257  //  Initialize             the    session           data
-
-258  MemorySet(session,                   0,     sizeof(SESSION));
-
-259
-
-260  //  Initialize             internal          session       data
-
-261  session->authHashAlg                     =   authHash;
-
-262  //  Initialize             session          type
-
-263  if(sessionType             ==     TPM_SE_HMAC)
-
-264  {
-
-265         *sessionHandle                +=     HMAC_SESSION_FIRST;
-
-266
-
-267  }
-
-268  else
-
-269  {
-
-270         *sessionHandle                +=     POLICY_SESSION_FIRST;
-
-271
-
-272         //  For     TPM_SE_POLICY                 or   TPM_SE_TRIAL
-
-273         session->attributes.isPolicy                              =  SET;
-
-274         if(sessionType                ==     TPM_SE_TRIAL)
-
-275                 session->attributes.isTrialPolicy                                   =   SET;
-
-276
-
-277         //  Initialize             policy         session         data
-
-278         SessionInitPolicyData(session);
-
-279  }
-
-280  //  Create         initial        session           nonce
-
-281  session->nonceTPM.t.size                         =   nonceCaller->t.size;
-
-282  CryptGenerateRandom(session->nonceTPM.t.size,                                              session->nonceTPM.t.buffer);
-
-283
-
-284  //  Set    up      session        parameter           encryption            algorithm
-
-285  session->symmetric                   =   *symmetric;
-
-286
-
-287  //  If     there       is  a     bind       object     or     a     session        secret,     then   need     to   compute
-
-288  //  a     sessionKey.
-
-289  if(bind        !=  TPM_RH_NULL               ||     seed->t.size            !=     0)
-
-290  {
-
-291         //  sessionKey             =     KDFa(hash,         (authValue              ||  seed),     "ATH",      nonceTPM,
-
-292         //                                             nonceCaller,              bits)
-
-293         //  The     HMAC       key       for   generating            the     sessionSecret         can     be   the  concatenation
-
-294         //  of      an  authorization                 value       and    a   seed       value
-
-295         TPM2B_TYPE(KEY,                  (sizeof(TPMT_HA)                +   sizeof(seed->t.buffer)));
-
-296         TPM2B_KEY                                 key;
-
-297
-
-298         UINT16                                    hashSize;                     //     The  size   of  the     hash  used  by   the
-
-299                                                                                 //     session     crated   by  this  command
-
-300         TPM2B_AUTH             entityAuth;                                      //     The  authValue      of   the  entity
+235               //  Is      this    available?
+           
+236               if(s_sessions[slotIndex].occupied                                   ==   FALSE)
+           
+237               {
+           
+238                       session        =   &s_sessions[slotIndex].session;
+           
+239                       break;
+           
+240               }
+           
+241        }
+           
+242        //  if     no  spot        found,        then       this   is       an  internal           error
+           
+243        pAssert        (slotIndex            <   MAX_LOADED_SESSIONS);
+           
+244        
+           
+245        //  Call       context        ID     function         to   get      a   handle.            TPM_RC_SESSION_HANDLE          may  be
+           
+246        //  returned           from      ContextIdHandelAssign()
+           
+247        result     =   ContextIdSessionCreate(sessionHandle,                                       slotIndex);
+           
+248        if(result          !=  TPM_RC_SUCCESS)
+           
+249               return      result;
+           
+250        
+           
+251        //***      Only    return         from       this     point         on  is     TPM_RC_SUCCESS
+           
+252        
+           
+253        //  Can    now     indicate             that     the   session          array         entry   is  occupied.
+           
+254        s_freeSessionSlots--;
+           
+255        s_sessions[slotIndex].occupied                             =     TRUE;
+           
+256        
+           
+257        //  Initialize             the    session           data
+           
+258        MemorySet(session,                   0,     sizeof(SESSION));
+           
+259        
+           
+260        //  Initialize             internal          session       data
+           
+261        session->authHashAlg                     =   authHash;
+           
+262        //  Initialize             session          type
+           
+263        if(sessionType             ==     TPM_SE_HMAC)
+           
+264        {
+           
+265               *sessionHandle                +=     HMAC_SESSION_FIRST;
+           
+266        
+           
+267        }
+           
+268        else
+           
+269        {
+           
+270               *sessionHandle                +=     POLICY_SESSION_FIRST;
+           
+271        
+           
+272               //  For     TPM_SE_POLICY                 or   TPM_SE_TRIAL
+           
+273               session->attributes.isPolicy                              =  SET;
+           
+274               if(sessionType                ==     TPM_SE_TRIAL)
+           
+275                       session->attributes.isTrialPolicy                                   =   SET;
+           
+276        
+           
+277               //  Initialize             policy         session         data
+           
+278               SessionInitPolicyData(session);
+           
+279        }
+           
+280        //  Create         initial        session           nonce
+           
+281        session->nonceTPM.t.size                         =   nonceCaller->t.size;
+           
+282        CryptGenerateRandom(session->nonceTPM.t.size,                                              session->nonceTPM.t.buffer);
+           
+283        
+           
+284        //  Set    up      session        parameter           encryption            algorithm
+           
+285        session->symmetric                   =   *symmetric;
+           
+286        
+           
+287        //  If     there       is  a     bind       object     or     a     session        secret,     then   need     to   compute
+           
+288        //  a     sessionKey.
+           
+289        if(bind        !=  TPM_RH_NULL               ||     seed->t.size            !=     0)
+           
+290        {
+           
+291               //  sessionKey             =     KDFa(hash,         (authValue              ||  seed),     "ATH",      nonceTPM,
+           
+292               //                                             nonceCaller,              bits)
+           
+293               //  The     HMAC       key       for   generating            the     sessionSecret         can     be   the  concatenation
+           
+294               //  of      an  authorization                 value       and    a   seed       value
+           
+295               TPM2B_TYPE(KEY,                  (sizeof(TPMT_HA)                +   sizeof(seed->t.buffer)));
+           
+296               TPM2B_KEY                                 key;
+           
+297        
+           
+298               UINT16                                    hashSize;                     //     The  size   of  the     hash  used  by   the
+           
+299                                                                                       //     session     crated   by  this  command
+           
+300               TPM2B_AUTH             entityAuth;                                      //     The  authValue      of   the  entity
 
      Page 200                                                      TCG Published                                                    Family "2.0"
 
@@ -27042,472 +27042,246 @@ Level 00 Revision 01.16      Copyright 
 
 133  static   const  COMMAND_ATTRIBUTES             s_commandAttributes  []  =  {
 
-134      (_ATTR_)(CC_NV_UndefineSpaceSpecial                 *
-
-     (IS_IMPLEMENTED+HANDLE_1_ADMIN+HANDLE_2_USER+PP_COMMAND)),                               //  0x011f
-
-135      (_ATTR_)(CC_EvictControl                            *
-
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0120
-
-136      (_ATTR_)(CC_HierarchyControl                        *
-
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0121
-
-137      (_ATTR_)(CC_NV_UndefineSpace                        *
-
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0122
-
-138      (_ATTR_)                                                 (NOT_IMPLEMENTED),
+134      (_ATTR_)(CC_NV_UndefineSpaceSpecial                 *  (IS_IMPLEMENTED+HANDLE_1_ADMIN+HANDLE_2_USER+PP_COMMAND)),                               //  0x011f
 
-     //  0x0123  -   Not  assigned
+135      (_ATTR_)(CC_EvictControl                            *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0120
 
-139      (_ATTR_)(CC_ChangeEPS                               *
+136      (_ATTR_)(CC_HierarchyControl                        *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0121
 
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0124
+137      (_ATTR_)(CC_NV_UndefineSpace                        *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0122
 
-140      (_ATTR_)(CC_ChangePPS                               *
+138      (_ATTR_)                                                 (NOT_IMPLEMENTED),  //  0x0123  -   Not  assigned
 
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0125
+139      (_ATTR_)(CC_ChangeEPS                               *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0124
 
-141      (_ATTR_)(CC_Clear                                   *
+140      (_ATTR_)(CC_ChangePPS                               *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0125
 
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0126
+141      (_ATTR_)(CC_Clear                                   *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0126
 
-142      (_ATTR_)(CC_ClearControl                            *
+142      (_ATTR_)(CC_ClearControl                            *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0127
 
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0127
+143      (_ATTR_)(CC_ClockSet                                *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0128
 
-143      (_ATTR_)(CC_ClockSet                                *
+144      (_ATTR_)(CC_HierarchyChangeAuth                     *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x0129
 
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0128
+145      (_ATTR_)(CC_NV_DefineSpace                          *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x012a
 
-144      (_ATTR_)(CC_HierarchyChangeAuth                     *
+146      (_ATTR_)(CC_PCR_Allocate                            *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x012b
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x0129
+147      (_ATTR_)(CC_PCR_SetAuthPolicy                       *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x012c
 
-145      (_ATTR_)(CC_NV_DefineSpace                          *
+148      (_ATTR_)(CC_PP_Commands                             *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_REQUIRED)),                                             //  0x012d
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x012a
+149      (_ATTR_)(CC_SetPrimaryPolicy                        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x012e
 
-146      (_ATTR_)(CC_PCR_Allocate                            *
+150      (_ATTR_)(CC_FieldUpgradeStart                       *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+PP_COMMAND)),                                   //  0x012f
 
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x012b
-
-147      (_ATTR_)(CC_PCR_SetAuthPolicy                       *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x012c
-
-148      (_ATTR_)(CC_PP_Commands                             *
-
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_REQUIRED)),                                             //  0x012d
-
-149      (_ATTR_)(CC_SetPrimaryPolicy                        *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND)),                                    //  0x012e
-
-150      (_ATTR_)(CC_FieldUpgradeStart                       *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+PP_COMMAND)),                                   //  0x012f
-
-151      (_ATTR_)(CC_ClockRateAdjust                         *
-
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0130
+151      (_ATTR_)(CC_ClockRateAdjust                         *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                              //  0x0130
 
      Page 220                                       TCG Published                                 Family "2.0"
 
      October 30, 2014                      Copyright © TCG 2006-2014                    Level 00 Revision 01.16
      Part 4: Supporting Routines                                 Trusted Platform Module Library
 
-152      (_ATTR_)(CC_CreatePrimary                *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND+ENCRYPT_2+R_HANDLE)),      //  0x0131
-
-153      (_ATTR_)(CC_NV_GlobalWriteLock           *
-
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                   //  0x0132
-
-154      (_ATTR_)(CC_GetCommandAuditDigest        *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),            //  0x0133
-
-155      (_ATTR_)(CC_NV_Increment                 *  (IS_IMPLEMENTED+HANDLE_1_USER)),
-
-     //  0x0134
-
-156      (_ATTR_)(CC_NV_SetBits                   *  (IS_IMPLEMENTED+HANDLE_1_USER)),
-
-     //  0x0135
-
-157      (_ATTR_)(CC_NV_Extend                    *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x0136
-
-158      (_ATTR_)(CC_NV_Write                     *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x0137
-
-159      (_ATTR_)(CC_NV_WriteLock                 *  (IS_IMPLEMENTED+HANDLE_1_USER)),
-
-     //  0x0138
-
-160      (_ATTR_)(CC_DictionaryAttackLockReset    *  (IS_IMPLEMENTED+HANDLE_1_USER)),
-
-     //  0x0139
-
-161      (_ATTR_)(CC_DictionaryAttackParameters   *  (IS_IMPLEMENTED+HANDLE_1_USER)),
-
-     //  0x013a
-
-162      (_ATTR_)(CC_NV_ChangeAuth                *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN)),                                   //  0x013b
-
-163      (_ATTR_)(CC_PCR_Event                    *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x013c
-
-164      (_ATTR_)(CC_PCR_Reset                    *  (IS_IMPLEMENTED+HANDLE_1_USER)),
-
-     //  0x013d
-
-165      (_ATTR_)(CC_SequenceComplete             *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                          //  0x013e
-
-166      (_ATTR_)(CC_SetAlgorithmSet              *  (IS_IMPLEMENTED+HANDLE_1_USER)),
-
-     //  0x013f
-
-167      (_ATTR_)(CC_SetCommandCodeAuditStatus    *
-
-     (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                   //  0x0140
-
-168      (_ATTR_)(CC_FieldUpgradeData             *  (IS_IMPLEMENTED+DECRYPT_2)),
-
-     //  0x0141
+152      (_ATTR_)(CC_CreatePrimary                *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+PP_COMMAND+ENCRYPT_2+R_HANDLE)),      //  0x0131
 
-169      (_ATTR_)(CC_IncrementalSelfTest          *  (IS_IMPLEMENTED)),
+153      (_ATTR_)(CC_NV_GlobalWriteLock           *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                   //  0x0132
 
-     //  0x0142
+154      (_ATTR_)(CC_GetCommandAuditDigest        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),            //  0x0133
 
-170      (_ATTR_)(CC_SelfTest                     *  (IS_IMPLEMENTED)),
+155      (_ATTR_)(CC_NV_Increment                 *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0134
 
-     //  0x0143
+156      (_ATTR_)(CC_NV_SetBits                   *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0135
 
-171      (_ATTR_)(CC_Startup                      *  (IS_IMPLEMENTED+NO_SESSIONS)),
+157      (_ATTR_)(CC_NV_Extend                    *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x0136
 
-     //  0x0144
+158      (_ATTR_)(CC_NV_Write                     *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x0137
 
-172      (_ATTR_)(CC_Shutdown                     *  (IS_IMPLEMENTED)),
+159      (_ATTR_)(CC_NV_WriteLock                 *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0138
 
-     //  0x0145
+160      (_ATTR_)(CC_DictionaryAttackLockReset    *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0139
 
-173      (_ATTR_)(CC_StirRandom                   *  (IS_IMPLEMENTED+DECRYPT_2)),
+161      (_ATTR_)(CC_DictionaryAttackParameters   *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x013a
 
-     //  0x0146
+162      (_ATTR_)(CC_NV_ChangeAuth                *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN)),                                   //  0x013b
 
-174      (_ATTR_)(CC_ActivateCredential           *
+163      (_ATTR_)(CC_PCR_Event                    *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x013c
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+HANDLE_2_USER+ENCRYPT_2)),           //  0x0147
+164      (_ATTR_)(CC_PCR_Reset                    *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x013d
 
-175      (_ATTR_)(CC_Certify                      *
+165      (_ATTR_)(CC_SequenceComplete             *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                          //  0x013e
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+HANDLE_2_USER+ENCRYPT_2)),           //  0x0148
+166      (_ATTR_)(CC_SetAlgorithmSet              *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x013f
 
-176      (_ATTR_)(CC_PolicyNV                     *
+167      (_ATTR_)(CC_SetCommandCodeAuditStatus    *  (IS_IMPLEMENTED+HANDLE_1_USER+PP_COMMAND)),                                   //  0x0140
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x0149
+168      (_ATTR_)(CC_FieldUpgradeData             *  (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0141
 
-177      (_ATTR_)(CC_CertifyCreation              *
+169      (_ATTR_)(CC_IncrementalSelfTest          *  (IS_IMPLEMENTED)),  //  0x0142
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                          //  0x014a
+170      (_ATTR_)(CC_SelfTest                     *  (IS_IMPLEMENTED)),  //  0x0143
 
-178      (_ATTR_)(CC_Duplicate                    *
+171      (_ATTR_)(CC_Startup                      *  (IS_IMPLEMENTED+NO_SESSIONS)),  //  0x0144
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_DUP+ENCRYPT_2)),                           //  0x014b
+172      (_ATTR_)(CC_Shutdown                     *  (IS_IMPLEMENTED)),  //  0x0145
 
-179      (_ATTR_)(CC_GetTime                      *
+173      (_ATTR_)(CC_StirRandom                   *  (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0146
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),            //  0x014c
+174      (_ATTR_)(CC_ActivateCredential           *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+HANDLE_2_USER+ENCRYPT_2)),           //  0x0147
 
-180      (_ATTR_)(CC_GetSessionAuditDigest        *
+175      (_ATTR_)(CC_Certify                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+HANDLE_2_USER+ENCRYPT_2)),           //  0x0148
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),            //  0x014d
+176      (_ATTR_)(CC_PolicyNV                     *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                    //  0x0149
 
-181      (_ATTR_)(CC_NV_Read                      *
+177      (_ATTR_)(CC_CertifyCreation              *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                          //  0x014a
 
-     (IS_IMPLEMENTED+HANDLE_1_USER+ENCRYPT_2)),                                    //  0x014e
+178      (_ATTR_)(CC_Duplicate                    *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_DUP+ENCRYPT_2)),                           //  0x014b
 
-182      (_ATTR_)(CC_NV_ReadLock                  *  (IS_IMPLEMENTED+HANDLE_1_USER)),
+179      (_ATTR_)(CC_GetTime                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),            //  0x014c
 
-     //  0x014f
+180      (_ATTR_)(CC_GetSessionAuditDigest        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),            //  0x014d
 
-183      (_ATTR_)(CC_ObjectChangeAuth             *
+181      (_ATTR_)(CC_NV_Read                      *  (IS_IMPLEMENTED+HANDLE_1_USER+ENCRYPT_2)),                                    //  0x014e
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+ENCRYPT_2)),                         //  0x0150
+182      (_ATTR_)(CC_NV_ReadLock                  *  (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x014f
 
-184      (_ATTR_)(CC_PolicySecret                 *
+183      (_ATTR_)(CC_ObjectChangeAuth             *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_ADMIN+ENCRYPT_2)),                         //  0x0150
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                          //  0x0151
+184      (_ATTR_)(CC_PolicySecret                 *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                          //  0x0151
 
      Family "2.0"                           TCG Published                              Page 221
 
      Level 00 Revision 01.16          Copyright © TCG 2006-2014                October 30, 2014
      Trusted Platform Module Library                                      Part 4: Supporting Routines
 
-185      (_ATTR_)(CC_Rewrap                      *
+185      (_ATTR_)(CC_Rewrap                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0152
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0152
+186      (_ATTR_)(CC_Create                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0153
 
-186      (_ATTR_)(CC_Create                      *
+187      (_ATTR_)(CC_ECDH_ZGen                   *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0154
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0153
+188      (_ATTR_)(CC_HMAC                        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0155
 
-187      (_ATTR_)(CC_ECDH_ZGen                   *
+189      (_ATTR_)(CC_Import                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0156
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0154
+190      (_ATTR_)(CC_Load                        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2+R_HANDLE)),                  //  0x0157
 
-188      (_ATTR_)(CC_HMAC                        *
+191      (_ATTR_)(CC_Quote                       *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0158
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0155
+192      (_ATTR_)(CC_RSA_Decrypt                 *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0159
 
-189      (_ATTR_)(CC_Import                      *
+193      (_ATTR_)                                     (NOT_IMPLEMENTED),  //  0x015a  -  Not  assigned
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0156
+194      (_ATTR_)(CC_HMAC_Start                  *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+R_HANDLE)),                            //  0x015b
 
-190      (_ATTR_)(CC_Load                        *
+195      (_ATTR_)(CC_SequenceUpdate              *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                     //  0x015c
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2+R_HANDLE)),                  //  0x0157
+196      (_ATTR_)(CC_Sign                        *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                     //  0x015d
 
-191      (_ATTR_)(CC_Quote                       *
+197      (_ATTR_)(CC_Unseal                      *  (IS_IMPLEMENTED+HANDLE_1_USER+ENCRYPT_2)),                                     //  0x015e
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0158
+198      (_ATTR_)                                     (NOT_IMPLEMENTED),  //  0x015f  -  Not  assigned
 
-192      (_ATTR_)(CC_RSA_Decrypt                 *
+199      (_ATTR_)(CC_PolicySigned                *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),  //  0x0160
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x0159
+200      (_ATTR_)(CC_ContextLoad                 *    (IS_IMPLEMENTED+NO_SESSIONS+R_HANDLE)),  //  0x0161
 
-193      (_ATTR_)                                     (NOT_IMPLEMENTED),
+201      (_ATTR_)(CC_ContextSave                 *    (IS_IMPLEMENTED+NO_SESSIONS)),  //  0x0162
 
-     //  0x015a  -  Not  assigned
+202      (_ATTR_)(CC_ECDH_KeyGen                 *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0163
 
-194      (_ATTR_)(CC_HMAC_Start                  *
+203      (_ATTR_)(CC_EncryptDecrypt              *  (IS_IMPLEMENTED+HANDLE_1_USER+ENCRYPT_2)),                                     //  0x0164
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+R_HANDLE)),                            //  0x015b
+204      (_ATTR_)(CC_FlushContext                *    (IS_IMPLEMENTED+NO_SESSIONS)),  //  0x0165
 
-195      (_ATTR_)(CC_SequenceUpdate              *
+205      (_ATTR_)                                     (NOT_IMPLEMENTED),  //  0x0166  -  Not  assigned
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                     //  0x015c
+206      (_ATTR_)(CC_LoadExternal                *  (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2+R_HANDLE)),                                //  0x0167
 
-196      (_ATTR_)(CC_Sign                        *
+207      (_ATTR_)(CC_MakeCredential              *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),  //  0x0168
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                     //  0x015d
+208      (_ATTR_)(CC_NV_ReadPublic               *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0169
 
-197      (_ATTR_)(CC_Unseal                      *
+209      (_ATTR_)(CC_PolicyAuthorize             *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x016a
 
-     (IS_IMPLEMENTED+HANDLE_1_USER+ENCRYPT_2)),                                     //  0x015e
+210      (_ATTR_)(CC_PolicyAuthValue             *    (IS_IMPLEMENTED)),  //  0x016b
 
-198      (_ATTR_)                                     (NOT_IMPLEMENTED),
+211      (_ATTR_)(CC_PolicyCommandCode           *    (IS_IMPLEMENTED)),  //  0x016c
 
-     //  0x015f  -  Not  assigned
+212      (_ATTR_)(CC_PolicyCounterTimer          *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x016d
 
-199      (_ATTR_)(CC_PolicySigned                *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),
+213      (_ATTR_)(CC_PolicyCpHash                *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x016e
 
-     //  0x0160
+214      (_ATTR_)(CC_PolicyLocality              *    (IS_IMPLEMENTED)),  //  0x016f
 
-200      (_ATTR_)(CC_ContextLoad                 *    (IS_IMPLEMENTED+NO_SESSIONS+R_HANDLE)),
+215      (_ATTR_)(CC_PolicyNameHash              *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0170
 
-     //  0x0161
+216      (_ATTR_)(CC_PolicyOR                    *    (IS_IMPLEMENTED)),  //  0x0171
 
-201      (_ATTR_)(CC_ContextSave                 *    (IS_IMPLEMENTED+NO_SESSIONS)),
-
-     //  0x0162
-
-202      (_ATTR_)(CC_ECDH_KeyGen                 *    (IS_IMPLEMENTED+ENCRYPT_2)),
-
-     //  0x0163
-
-203      (_ATTR_)(CC_EncryptDecrypt              *
-
-     (IS_IMPLEMENTED+HANDLE_1_USER+ENCRYPT_2)),                                     //  0x0164
-
-204      (_ATTR_)(CC_FlushContext                *    (IS_IMPLEMENTED+NO_SESSIONS)),
-
-     //  0x0165
-
-205      (_ATTR_)                                     (NOT_IMPLEMENTED),
-
-     //  0x0166  -  Not  assigned
-
-206      (_ATTR_)(CC_LoadExternal                *
-
-     (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2+R_HANDLE)),                                //  0x0167
-
-207      (_ATTR_)(CC_MakeCredential              *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),
-
-     //  0x0168
-
-208      (_ATTR_)(CC_NV_ReadPublic               *    (IS_IMPLEMENTED+ENCRYPT_2)),
-
-     //  0x0169
-
-209      (_ATTR_)(CC_PolicyAuthorize             *    (IS_IMPLEMENTED+DECRYPT_2)),
-
-     //  0x016a
-
-210      (_ATTR_)(CC_PolicyAuthValue             *    (IS_IMPLEMENTED)),
-
-     //  0x016b
-
-211      (_ATTR_)(CC_PolicyCommandCode           *    (IS_IMPLEMENTED)),
-
-     //  0x016c
-
-212      (_ATTR_)(CC_PolicyCounterTimer          *    (IS_IMPLEMENTED+DECRYPT_2)),
-
-     //  0x016d
-
-213      (_ATTR_)(CC_PolicyCpHash                *    (IS_IMPLEMENTED+DECRYPT_2)),
-
-     //  0x016e
-
-214      (_ATTR_)(CC_PolicyLocality              *    (IS_IMPLEMENTED)),
-
-     //  0x016f
-
-215      (_ATTR_)(CC_PolicyNameHash              *    (IS_IMPLEMENTED+DECRYPT_2)),
-
-     //  0x0170
-
-216      (_ATTR_)(CC_PolicyOR                    *    (IS_IMPLEMENTED)),
-
-     //  0x0171
-
-217      (_ATTR_)(CC_PolicyTicket                *    (IS_IMPLEMENTED+DECRYPT_2)),
-
-     //  0x0172
+217      (_ATTR_)(CC_PolicyTicket                *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0172
 
      Page 222                            TCG Published                                  Family "2.0"
 
      October 30, 2014                 Copyright © TCG 2006-2014           Level 00 Revision 01.16
      Part 4: Supporting Routines                                 Trusted Platform Module Library
 
-218      (_ATTR_)(CC_ReadPublic                  *    (IS_IMPLEMENTED+ENCRYPT_2)),
-
-     //  0x0173
-
-219      (_ATTR_)(CC_RSA_Encrypt                 *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),
-
-     //  0x0174
-
-220      (_ATTR_)                                     (NOT_IMPLEMENTED),
-
-     //  0x0175  -  Not  assigned
-
-221      (_ATTR_)(CC_StartAuthSession            *
-
-     (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2+R_HANDLE)),                                //  0x0176
-
-222      (_ATTR_)(CC_VerifySignature             *    (IS_IMPLEMENTED+DECRYPT_2)),
-
-     //  0x0177
-
-223      (_ATTR_)(CC_ECC_Parameters              *    (IS_IMPLEMENTED)),
+218      (_ATTR_)(CC_ReadPublic                  *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0173
 
-     //  0x0178
+219      (_ATTR_)(CC_RSA_Encrypt                 *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),  //  0x0174
 
-224      (_ATTR_)(CC_FirmwareRead                *    (IS_IMPLEMENTED+ENCRYPT_2)),
+220      (_ATTR_)                                     (NOT_IMPLEMENTED),  //  0x0175  -  Not  assigned
 
-     //  0x0179
+221      (_ATTR_)(CC_StartAuthSession            *  (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2+R_HANDLE)),                                //  0x0176
 
-225      (_ATTR_)(CC_GetCapability               *    (IS_IMPLEMENTED)),
+222      (_ATTR_)(CC_VerifySignature             *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0177
 
-     //  0x017a
+223      (_ATTR_)(CC_ECC_Parameters              *    (IS_IMPLEMENTED)),  //  0x0178
 
-226      (_ATTR_)(CC_GetRandom                   *    (IS_IMPLEMENTED+ENCRYPT_2)),
+224      (_ATTR_)(CC_FirmwareRead                *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0179
 
-     //  0x017b
+225      (_ATTR_)(CC_GetCapability               *    (IS_IMPLEMENTED)),  //  0x017a
 
-227      (_ATTR_)(CC_GetTestResult               *    (IS_IMPLEMENTED+ENCRYPT_2)),
+226      (_ATTR_)(CC_GetRandom                   *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x017b
 
-     //  0x017c
+227      (_ATTR_)(CC_GetTestResult               *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x017c
 
-228      (_ATTR_)(CC_Hash                        *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),
+228      (_ATTR_)(CC_Hash                        *    (IS_IMPLEMENTED+DECRYPT_2+ENCRYPT_2)),  //  0x017d
 
-     //  0x017d
+229      (_ATTR_)(CC_PCR_Read                    *    (IS_IMPLEMENTED)),  //  0x017e
 
-229      (_ATTR_)(CC_PCR_Read                    *    (IS_IMPLEMENTED)),
+230      (_ATTR_)(CC_PolicyPCR                   *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x017f
 
-     //  0x017e
+231      (_ATTR_)(CC_PolicyRestart               *    (IS_IMPLEMENTED)),  //  0x0180
 
-230      (_ATTR_)(CC_PolicyPCR                   *    (IS_IMPLEMENTED+DECRYPT_2)),
+232      (_ATTR_)(CC_ReadClock                   *    (IS_IMPLEMENTED+NO_SESSIONS)),  //  0x0181
 
-     //  0x017f
+233      (_ATTR_)(CC_PCR_Extend                  *    (IS_IMPLEMENTED+HANDLE_1_USER)),  //  0x0182
 
-231      (_ATTR_)(CC_PolicyRestart               *    (IS_IMPLEMENTED)),
+234      (_ATTR_)(CC_PCR_SetAuthValue            *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                     //  0x0183
 
-     //  0x0180
+235      (_ATTR_)(CC_NV_Certify                  *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),             //  0x0184
 
-232      (_ATTR_)(CC_ReadClock                   *    (IS_IMPLEMENTED+NO_SESSIONS)),
+236      (_ATTR_)(CC_EventSequenceComplete       *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER)),                       //  0x0185
 
-     //  0x0181
+237      (_ATTR_)(CC_HashSequenceStart           *    (IS_IMPLEMENTED+DECRYPT_2+R_HANDLE)),  //  0x0186
 
-233      (_ATTR_)(CC_PCR_Extend                  *    (IS_IMPLEMENTED+HANDLE_1_USER)),
+238      (_ATTR_)(CC_PolicyPhysicalPresence      *    (IS_IMPLEMENTED)),  //  0x0187
 
-     //  0x0182
+239      (_ATTR_)(CC_PolicyDuplicationSelect     *    (IS_IMPLEMENTED+DECRYPT_2)),  //  0x0188
 
-234      (_ATTR_)(CC_PCR_SetAuthValue            *
+240      (_ATTR_)(CC_PolicyGetDigest             *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x0189
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER)),                                     //  0x0183
+241      (_ATTR_)(CC_TestParms                   *    (IS_IMPLEMENTED)),  //  0x018a
 
-235      (_ATTR_)(CC_NV_Certify                  *
+242      (_ATTR_)(CC_Commit                      *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x018b
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER+ENCRYPT_2)),             //  0x0184
+243      (_ATTR_)(CC_PolicyPassword              *    (IS_IMPLEMENTED)),  //  0x018c
 
-236      (_ATTR_)(CC_EventSequenceComplete       *
+244      (_ATTR_)(CC_ZGen_2Phase                 *  (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x018d
 
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+HANDLE_2_USER)),                       //  0x0185
+245      (_ATTR_)(CC_EC_Ephemeral                *    (IS_IMPLEMENTED+ENCRYPT_2)),  //  0x018e
 
-237      (_ATTR_)(CC_HashSequenceStart           *    (IS_IMPLEMENTED+DECRYPT_2+R_HANDLE)),
-
-     //  0x0186
-
-238      (_ATTR_)(CC_PolicyPhysicalPresence      *    (IS_IMPLEMENTED)),
-
-     //  0x0187
-
-239      (_ATTR_)(CC_PolicyDuplicationSelect     *    (IS_IMPLEMENTED+DECRYPT_2)),
-
-     //  0x0188
-
-240      (_ATTR_)(CC_PolicyGetDigest             *    (IS_IMPLEMENTED+ENCRYPT_2)),
-
-     //  0x0189
-
-241      (_ATTR_)(CC_TestParms                   *    (IS_IMPLEMENTED)),
-
-     //  0x018a
-
-242      (_ATTR_)(CC_Commit                      *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x018b
-
-243      (_ATTR_)(CC_PolicyPassword              *    (IS_IMPLEMENTED)),
-
-     //  0x018c
-
-244      (_ATTR_)(CC_ZGen_2Phase                 *
-
-     (IS_IMPLEMENTED+DECRYPT_2+HANDLE_1_USER+ENCRYPT_2)),                           //  0x018d
-
-245      (_ATTR_)(CC_EC_Ephemeral                *    (IS_IMPLEMENTED+ENCRYPT_2)),
-
-     //  0x018e
-
-246      (_ATTR_)(CC_PolicyNvWritten             *    (IS_IMPLEMENTED))
-
-     //  0x018f
+246      (_ATTR_)(CC_PolicyNvWritten             *    (IS_IMPLEMENTED))  //  0x018f
 
 247  };
 
@@ -27588,9 +27362,7 @@ Level 00 Revision 01.16      Copyright 
 
 19       }
 
-20       if(s_commandAttributes[commandCode                 -  TPM_CC_FIRST]           &   HANDLE_2_USER)          return
-
-    AUTH_USER;
+20       if(s_commandAttributes[commandCode                 -  TPM_CC_FIRST]           &   HANDLE_2_USER)          return AUTH_USER;
 
 21       return   AUTH_NONE;
 
@@ -31248,547 +31020,547 @@ Level 00 Revision 01.16      Copyright 
      Level 00 Revision 01.16                    Copyright © TCG 2006-2014                                           October 30, 2014
      Trusted Platform Module Library                                                                      Part 4: Supporting Routines
 
-112            break;
-
-113  case      TPM_PT_NV_COUNTERS_MAX:
-
-114            //      maximum       number     of     NV  indexes       that    are     allowed    to      have  the
-
-115            //      TPMA_NV_COUNTER          attribute          SET
-
-116            //      In   this     implementation,            there      is   no   limitation       on    the   number
-
-117            //      of   counters,       except         for  the   size      of   the     NV   Index     memory.
-
-118            *value        =   0;
-
-119            break;
-
-120  case      TPM_PT_NV_INDEX_MAX:
-
-121            //      maximum       size   of  an     NV   index     data      area
-
-122            *value        =   MAX_NV_INDEX_SIZE;
-
-123            break;
-
-124  case      TPM_PT_MEMORY:
-
-125            //      a   TPMA_MEMORY       indicating         the      memory      management       method      for  the  TPM
-
-126  {
-
-127            TPMA_MEMORY                          attributes        =    {0};
-
-128            attributes.sharedNV                  =  SET;
-
-129            attributes.objectCopiedToRam                        =  SET;
-
-130
-
-131            //      Note:     Different      compilers          may     require       a   different      method     to   cast
-
-132            //      a   bit   field     structure        to  a     UINT32.
-
-133            *value        =   *   (UINT32    *)     &attributes;
-
-134            break;
-
-135  }
-
-136  case      TPM_PT_CLOCK_UPDATE:
-
-137            //      interval,     in     seconds,        between        updates       to  the   copy     of
-
-138            //      TPMS_TIME_INFO           .clock      in  NV
-
-139            *value        =   (1  <<    NV_CLOCK_UPDATE_INTERVAL);
-
-140            break;
-
-141  case      TPM_PT_CONTEXT_HASH:
-
-142            //      algorithm     used       for    the      integrity       hash     on  saved    contexts         and
-
-143            //      for   digesting       the       fuData   of    TPM2_FirmwareRead()
-
-144            *value        =   CONTEXT_INTEGRITY_HASH_ALG;
-
-145            break;
-
-146  case      TPM_PT_CONTEXT_SYM:
-
-147            //      algorithm     used       for    encryption          of   saved       contexts
-
-148            *value        =   CONTEXT_ENCRYPT_ALG;
-
-149            break;
-
-150  case      TPM_PT_CONTEXT_SYM_SIZE:
-
-151            //      size     of   the   key  used       for  encryption           of     saved  contexts
-
-152            *value        =   CONTEXT_ENCRYPT_KEY_BITS;
-
-153            break;
-
-154  case      TPM_PT_ORDERLY_COUNT:
-
-155            //      maximum       difference        between        the  volatile          and   non-volatile
-
-156            //      versions      of    TPMA_NV_COUNTER            that      have     TPMA_NV_ORDERLY          SET
-
-157            *value        =   MAX_ORDERLY_COUNT;
-
-158            break;
-
-159  case      TPM_PT_MAX_COMMAND_SIZE:
-
-160            //      maximum       value   for       'commandSize'
-
-161            *value        =   MAX_COMMAND_SIZE;
-
-162            break;
-
-163  case      TPM_PT_MAX_RESPONSE_SIZE:
-
-164            //      maximum       value   for       'responseSize'
-
-165            *value        =   MAX_RESPONSE_SIZE;
-
-166            break;
-
-167  case      TPM_PT_MAX_DIGEST:
-
-168            //      maximum       size   of  a      digest   that       can   be   produced      by      the   TPM
-
-169            *value        =   sizeof(TPMU_HA);
-
-170            break;
-
-171  case      TPM_PT_MAX_OBJECT_CONTEXT:
-
-172            //      maximum       size   of  a      TPMS_CONTEXT        that      will    be    returned       by
-
-173            //      TPM2_ContextSave             for    object     context
-
-174            *value        =   0;
-
-175
-
-176            //      adding       sequence,       saved       handle     and   hierarchy
-
-177            *value        +=     sizeof(UINT64)          +   sizeof(TPMI_DH_CONTEXT)                  +
+112                    break;
+             
+113          case      TPM_PT_NV_COUNTERS_MAX:
+             
+114                    //      maximum       number     of     NV  indexes       that    are     allowed    to      have  the
+             
+115                    //      TPMA_NV_COUNTER          attribute          SET
+             
+116                    //      In   this     implementation,            there      is   no   limitation       on    the   number
+             
+117                    //      of   counters,       except         for  the   size      of   the     NV   Index     memory.
+             
+118                    *value        =   0;
+             
+119                    break;
+             
+120          case      TPM_PT_NV_INDEX_MAX:
+             
+121                    //      maximum       size   of  an     NV   index     data      area
+             
+122                    *value        =   MAX_NV_INDEX_SIZE;
+             
+123                    break;
+             
+124          case      TPM_PT_MEMORY:
+             
+125                    //      a   TPMA_MEMORY       indicating         the      memory      management       method      for  the  TPM
+             
+126          {
+             
+127                    TPMA_MEMORY                          attributes        =    {0};
+             
+128                    attributes.sharedNV                  =  SET;
+             
+129                    attributes.objectCopiedToRam                        =  SET;
+             
+130          
+             
+131                    //      Note:     Different      compilers          may     require       a   different      method     to   cast
+             
+132                    //      a   bit   field     structure        to  a     UINT32.
+             
+133                    *value        =   *   (UINT32    *)     &attributes;
+             
+134                    break;
+             
+135          }
+             
+136          case      TPM_PT_CLOCK_UPDATE:
+             
+137                    //      interval,     in     seconds,        between        updates       to  the   copy     of
+             
+138                    //      TPMS_TIME_INFO           .clock      in  NV
+             
+139                    *value        =   (1  <<    NV_CLOCK_UPDATE_INTERVAL);
+             
+140                    break;
+             
+141          case      TPM_PT_CONTEXT_HASH:
+             
+142                    //      algorithm     used       for    the      integrity       hash     on  saved    contexts         and
+             
+143                    //      for   digesting       the       fuData   of    TPM2_FirmwareRead()
+             
+144                    *value        =   CONTEXT_INTEGRITY_HASH_ALG;
+             
+145                    break;
+             
+146          case      TPM_PT_CONTEXT_SYM:
+             
+147                    //      algorithm     used       for    encryption          of   saved       contexts
+             
+148                    *value        =   CONTEXT_ENCRYPT_ALG;
+             
+149                    break;
+             
+150          case      TPM_PT_CONTEXT_SYM_SIZE:
+             
+151                    //      size     of   the   key  used       for  encryption           of     saved  contexts
+             
+152                    *value        =   CONTEXT_ENCRYPT_KEY_BITS;
+             
+153                    break;
+             
+154          case      TPM_PT_ORDERLY_COUNT:
+             
+155                    //      maximum       difference        between        the  volatile          and   non-volatile
+             
+156                    //      versions      of    TPMA_NV_COUNTER            that      have     TPMA_NV_ORDERLY          SET
+             
+157                    *value        =   MAX_ORDERLY_COUNT;
+             
+158                    break;
+             
+159          case      TPM_PT_MAX_COMMAND_SIZE:
+             
+160                    //      maximum       value   for       'commandSize'
+             
+161                    *value        =   MAX_COMMAND_SIZE;
+             
+162                    break;
+             
+163          case      TPM_PT_MAX_RESPONSE_SIZE:
+             
+164                    //      maximum       value   for       'responseSize'
+             
+165                    *value        =   MAX_RESPONSE_SIZE;
+             
+166                    break;
+             
+167          case      TPM_PT_MAX_DIGEST:
+             
+168                    //      maximum       size   of  a      digest   that       can   be   produced      by      the   TPM
+             
+169                    *value        =   sizeof(TPMU_HA);
+             
+170                    break;
+             
+171          case      TPM_PT_MAX_OBJECT_CONTEXT:
+             
+172                    //      maximum       size   of  a      TPMS_CONTEXT        that      will    be    returned       by
+             
+173                    //      TPM2_ContextSave             for    object     context
+             
+174                    *value        =   0;
+             
+175          
+             
+176                    //      adding       sequence,       saved       handle     and   hierarchy
+             
+177                    *value        +=     sizeof(UINT64)          +   sizeof(TPMI_DH_CONTEXT)                  +
 
      Page 260                                              TCG Published                                                    Family "2.0"
 
      October 30, 2014                           Copyright © TCG 2006-2014                                   Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                  Trusted Platform Module Library
 
-178                               sizeof(TPMI_RH_HIERARCHY);
-
-179                //  add  size      field    in  TPM2B_CONTEXT
-
-180                *value   +=    sizeof(UINT16);
-
-181
-
-182                //  add  integrity        hash      size
-
-183                *value   +=    sizeof(UINT16)           +
-
-184                               CryptGetHashDigestSize(CONTEXT_INTEGRITY_HASH_ALG);
-
-185
-
-186                //  Add  fingerprint          size,     which      is  the   same        as   sequence   size
-
-187                *value   +=    sizeof(UINT64);
-
-188
-
-189                //  Add  OBJECT    structure            size
-
-190                *value   +=    sizeof(OBJECT);
-
-191                break;
-
-192  case          TPM_PT_MAX_SESSION_CONTEXT:
-
-193                //  the  maximum        size    of   a  TPMS_CONTEXT         that        will  be   returned      by
-
-194                //  TPM2_ContextSave            for     object     context
-
-195                *value   =   0;
-
-196
-
-197                //  adding     sequence,        saved      handle      and  hierarchy
-
-198                *value   +=    sizeof(UINT64)           +  sizeof(TPMI_DH_CONTEXT)                  +
-
-199                               sizeof(TPMI_RH_HIERARCHY);
-
-200                //  Add  size      field    in  TPM2B_CONTEXT
-
-201                *value   +=    sizeof(UINT16);
-
-202
-
-203                //  Add  integrity        hash      size
-
-204                *value   +=    sizeof(UINT16)           +
-
-205                               CryptGetHashDigestSize(CONTEXT_INTEGRITY_HASH_ALG);
-
-206                //  Add  fingerprint          size,     which      is  the   same        as   sequence   size
-
-207                *value   +=    sizeof(UINT64);
-
-208
-
-209                //  Add  SESSION        structure       size
-
-210                *value   +=    sizeof(SESSION);
-
-211                break;
-
-212  case          TPM_PT_PS_FAMILY_INDICATOR:
-
-213                //  platform       specific     values        for  the      TPM_PT_PS         parameters     from
-
-214                //  the  relevant       platform-specific              specification
-
-215                //  In   this    reference      implementation,             all      of  these      values   are   0.
-
-216                *value   =   0;
-
-217                break;
-
-218  case          TPM_PT_PS_LEVEL:
-
-219                //  level    of    the  platform-specific              specification
-
-220                *value   =   0;
-
-221                break;
-
-222  case          TPM_PT_PS_REVISION:
-
-223                //  specification         Revision         times   100      for  the     platform-specific
-
-224                //  specification
-
-225                *value   =   0;
-
-226                break;
-
-227  case          TPM_PT_PS_DAY_OF_YEAR:
-
-228                //  platform-specific           specification           day      of  year      using    TCG  calendar
-
-229                *value   =   0;
-
-230                break;
-
-231  case          TPM_PT_PS_YEAR:
-
-232                //  platform-specific           specification           year     using        the   CE
-
-233                *value   =   0;
-
-234                break;
-
-235  case          TPM_PT_SPLIT_MAX:
-
-236                //  number     of  split      signing      operations        supported         by   the  TPM
-
-237                *value   =   0;
-
+178                                       sizeof(TPMI_RH_HIERARCHY);
+             
+179                        //  add  size      field    in  TPM2B_CONTEXT
+             
+180                        *value   +=    sizeof(UINT16);
+             
+181          
+             
+182                        //  add  integrity        hash      size
+             
+183                        *value   +=    sizeof(UINT16)           +
+             
+184                                       CryptGetHashDigestSize(CONTEXT_INTEGRITY_HASH_ALG);
+             
+185          
+             
+186                        //  Add  fingerprint          size,     which      is  the   same        as   sequence   size
+             
+187                        *value   +=    sizeof(UINT64);
+             
+188          
+             
+189                        //  Add  OBJECT    structure            size
+             
+190                        *value   +=    sizeof(OBJECT);
+             
+191                        break;
+             
+192          case          TPM_PT_MAX_SESSION_CONTEXT:
+             
+193                        //  the  maximum        size    of   a  TPMS_CONTEXT         that        will  be   returned      by
+             
+194                        //  TPM2_ContextSave            for     object     context
+             
+195                        *value   =   0;
+             
+196          
+             
+197                        //  adding     sequence,        saved      handle      and  hierarchy
+             
+198                        *value   +=    sizeof(UINT64)           +  sizeof(TPMI_DH_CONTEXT)                  +
+             
+199                                       sizeof(TPMI_RH_HIERARCHY);
+             
+200                        //  Add  size      field    in  TPM2B_CONTEXT
+             
+201                        *value   +=    sizeof(UINT16);
+             
+202          
+             
+203                        //  Add  integrity        hash      size
+             
+204                        *value   +=    sizeof(UINT16)           +
+             
+205                                       CryptGetHashDigestSize(CONTEXT_INTEGRITY_HASH_ALG);
+             
+206                        //  Add  fingerprint          size,     which      is  the   same        as   sequence   size
+             
+207                        *value   +=    sizeof(UINT64);
+             
+208          
+             
+209                        //  Add  SESSION        structure       size
+             
+210                        *value   +=    sizeof(SESSION);
+             
+211                        break;
+             
+212          case          TPM_PT_PS_FAMILY_INDICATOR:
+             
+213                        //  platform       specific     values        for  the      TPM_PT_PS         parameters     from
+             
+214                        //  the  relevant       platform-specific              specification
+             
+215                        //  In   this    reference      implementation,             all      of  these      values   are   0.
+             
+216                        *value   =   0;
+             
+217                        break;
+             
+218          case          TPM_PT_PS_LEVEL:
+             
+219                        //  level    of    the  platform-specific              specification
+             
+220                        *value   =   0;
+             
+221                        break;
+             
+222          case          TPM_PT_PS_REVISION:
+             
+223                        //  specification         Revision         times   100      for  the     platform-specific
+             
+224                        //  specification
+             
+225                        *value   =   0;
+             
+226                        break;
+             
+227          case          TPM_PT_PS_DAY_OF_YEAR:
+             
+228                        //  platform-specific           specification           day      of  year      using    TCG  calendar
+             
+229                        *value   =   0;
+             
+230                        break;
+             
+231          case          TPM_PT_PS_YEAR:
+             
+232                        //  platform-specific           specification           year     using        the   CE
+             
+233                        *value   =   0;
+             
+234                        break;
+             
+235          case          TPM_PT_SPLIT_MAX:
+             
+236                        //  number     of  split      signing      operations        supported         by   the  TPM
+             
+237                        *value   =   0;
+             
 238  #ifdef        TPM_ALG_ECC
-
-239                *value   =   sizeof(gr.commitArray)                *   8;
-
+             
+239                        *value   =   sizeof(gr.commitArray)                *   8;
+             
 240  #endif
-
-241                break;
-
-242  case          TPM_PT_TOTAL_COMMANDS:
-
-243                //  total    number     of    commands        implemented        in      the   TPM
+             
+241                        break;
+             
+242          case          TPM_PT_TOTAL_COMMANDS:
+             
+243                        //  total    number     of    commands        implemented        in      the   TPM
 
      Family "2.0"                                          TCG Published                                                  Page 261
 
      Level 00 Revision 01.16                   Copyright © TCG 2006-2014                                          October 30, 2014
      Trusted Platform Module Library                                                                           Part 4: Supporting Routines
 
-244            //      Since      the    reference           implementation                does   not   have   any
-
-245            //      vendor-defined          commands,                this         will  be  the   same  as     the
-
-246            //      number        of  library       commands.
-
-247  {
-
-248            UINT32         i;
-
-249            *value         =   0;
-
-250
-
-251            //      calculate         implemented             command             numbers
-
-252            for(i       =     TPM_CC_FIRST;            i     <=   TPM_CC_LAST;              i++)
-
-253            {
-
-254                       if(CommandIsImplemented(i))                            (*value)++;
-
-255            }
-
-256            break;
-
-257  }
-
-258  case         TPM_PT_LIBRARY_COMMANDS:
-
-259            //      number        of  commands         from       the         TPM   library    that  are    implemented
-
-260  {
-
-261            UINT32         i;
-
-262            *value         =   0;
-
-263
-
-264            //      calculate         implemented             command             numbers
-
-265            for(i       =     TPM_CC_FIRST;            i     <=   TPM_CC_LAST;              i++)
-
-266            {
-
-267                       if(CommandIsImplemented(i))                            (*value)++;
-
-268            }
-
-269            break;
-
-270  }
-
-271  case         TPM_PT_VENDOR_COMMANDS:
-
-272            //      number        of  vendor     commands               that       are  implemented
-
-273            *value         =   0;
-
-274            break;
-
-275  case         TPM_PT_PERMANENT:
-
-276            //      TPMA_PERMANENT
-
-277  {
-
-278            TPMA_PERMANENT                                   flags         =  {0};
-
-279            if(gp.ownerAuth.t.size                        !=     0)
-
-280                       flags.ownerAuthSet                 =   SET;
-
-281            if(gp.endorsementAuth.t.size                                !=    0)
-
-282                       flags.endorsementAuthSet                         =     SET;
-
-283            if(gp.lockoutAuth.t.size                          !=     0)
-
-284                       flags.lockoutAuthSet                   =   SET;
-
-285            if(gp.disableClear)
-
-286                       flags.disableClear                 =   SET;
-
-287            if(gp.failedTries               >=      gp.maxTries)
-
-288                       flags.inLockout           =     SET;
-
-289            //      In  this       implementation,                EPS         is   always   generated      by  TPM
-
-290            flags.tpmGeneratedEPS                      =     SET;
-
-291
-
-292            //      Note:      Different      compilers                 may       require   a  different       method  to  cast
-
-293            //      a   bit    field  structure               to     a     UINT32.
-
-294            *value         =   *   (UINT32    *)       &flags;
-
-295            break;
-
-296  }
-
-297  case         TPM_PT_STARTUP_CLEAR:
-
-298            //      TPMA_STARTUP_CLEAR
-
-299  {
-
-300            TPMA_STARTUP_CLEAR                               flags         =  {0};
-
-301            if(g_phEnable)
-
-302                       flags.phEnable         =     SET;
-
-303            if(gc.shEnable)
-
-304                       flags.shEnable         =     SET;
-
-305            if(gc.ehEnable)
-
-306                       flags.ehEnable         =     SET;
-
-307            if(gc.phEnableNV)
-
-308                       flags.phEnableNV             =     SET;
-
-309            if(g_prevOrderlyState                      !=     SHUTDOWN_NONE)
+244                    //      Since      the    reference           implementation                does   not   have   any
+             
+245                    //      vendor-defined          commands,                this         will  be  the   same  as     the
+             
+246                    //      number        of  library       commands.
+             
+247          {
+             
+248                    UINT32         i;
+             
+249                    *value         =   0;
+             
+250          
+             
+251                    //      calculate         implemented             command             numbers
+             
+252                    for(i       =     TPM_CC_FIRST;            i     <=   TPM_CC_LAST;              i++)
+             
+253                    {
+             
+254                               if(CommandIsImplemented(i))                            (*value)++;
+             
+255                    }
+             
+256                    break;
+             
+257          }
+             
+258          case         TPM_PT_LIBRARY_COMMANDS:
+             
+259                    //      number        of  commands         from       the         TPM   library    that  are    implemented
+             
+260          {
+             
+261                    UINT32         i;
+             
+262                    *value         =   0;
+             
+263          
+             
+264                    //      calculate         implemented             command             numbers
+             
+265                    for(i       =     TPM_CC_FIRST;            i     <=   TPM_CC_LAST;              i++)
+             
+266                    {
+             
+267                               if(CommandIsImplemented(i))                            (*value)++;
+             
+268                    }
+             
+269                    break;
+             
+270          }
+             
+271          case         TPM_PT_VENDOR_COMMANDS:
+             
+272                    //      number        of  vendor     commands               that       are  implemented
+             
+273                    *value         =   0;
+             
+274                    break;
+             
+275          case         TPM_PT_PERMANENT:
+             
+276                    //      TPMA_PERMANENT
+             
+277          {
+             
+278                    TPMA_PERMANENT                                   flags         =  {0};
+             
+279                    if(gp.ownerAuth.t.size                        !=     0)
+             
+280                               flags.ownerAuthSet                 =   SET;
+             
+281                    if(gp.endorsementAuth.t.size                                !=    0)
+             
+282                               flags.endorsementAuthSet                         =     SET;
+             
+283                    if(gp.lockoutAuth.t.size                          !=     0)
+             
+284                               flags.lockoutAuthSet                   =   SET;
+             
+285                    if(gp.disableClear)
+             
+286                               flags.disableClear                 =   SET;
+             
+287                    if(gp.failedTries               >=      gp.maxTries)
+             
+288                               flags.inLockout           =     SET;
+             
+289                    //      In  this       implementation,                EPS         is   always   generated      by  TPM
+             
+290                    flags.tpmGeneratedEPS                      =     SET;
+             
+291          
+             
+292                    //      Note:      Different      compilers                 may       require   a  different       method  to  cast
+             
+293                    //      a   bit    field  structure               to     a     UINT32.
+             
+294                    *value         =   *   (UINT32    *)       &flags;
+             
+295                    break;
+             
+296          }
+             
+297          case         TPM_PT_STARTUP_CLEAR:
+             
+298                    //      TPMA_STARTUP_CLEAR
+             
+299          {
+             
+300                    TPMA_STARTUP_CLEAR                               flags         =  {0};
+             
+301                    if(g_phEnable)
+             
+302                               flags.phEnable         =     SET;
+             
+303                    if(gc.shEnable)
+             
+304                               flags.shEnable         =     SET;
+             
+305                    if(gc.ehEnable)
+             
+306                               flags.ehEnable         =     SET;
+             
+307                    if(gc.phEnableNV)
+             
+308                               flags.phEnableNV             =     SET;
+             
+309                    if(g_prevOrderlyState                      !=     SHUTDOWN_NONE)
 
      Page 262                                                   TCG Published                                                 Family "2.0"
 
      October 30, 2014                          Copyright © TCG 2006-2014                                          Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                    Trusted Platform Module Library
 
-310                       flags.orderly          =  SET;
-
-311
-
-312                //  Note:    Different           compilers           may  require     a  different       method  to    cast
-
-313                //  a   bit  field       structure       to       a  UINT32.
-
-314                *value    =  *   (UINT32         *)   &flags;
-
-315                break;
-
-316  }
-
-317  case          TPM_PT_HR_NV_INDEX:
-
-318                //  number       of  NV      indexes     currently        defined
-
-319                *value    =  NvCapGetIndexNumber();
-
-320                break;
-
-321  case          TPM_PT_HR_LOADED:
-
-322                //  number       of  authorization            sessions          currently        loaded  into   TPM
-
-323                //  RAM
-
-324                *value    =  SessionCapGetLoadedNumber();
-
-325                break;
-
-326  case          TPM_PT_HR_LOADED_AVAIL:
-
-327                //  number       of  additional          authorization          sessions,        of  any  type,
-
-328                //  that     could       be   loaded     into        TPM  RAM
-
-329                *value    =  SessionCapGetLoadedAvail();
-
-330                break;
-
-331  case          TPM_PT_HR_ACTIVE:
-
-332                //  number       of  active      authorization            sessions       currently       being
-
-333                //  tracked      by      the  TPM
-
-334                *value    =  SessionCapGetActiveNumber();
-
-335                break;
-
-336  case          TPM_PT_HR_ACTIVE_AVAIL:
-
-337                //  number       of  additional          authorization          sessions,        of  any  type,
-
-338                //  that     could       be   created
-
-339                *value    =  SessionCapGetActiveAvail();
-
-340                break;
-
-341  case          TPM_PT_HR_TRANSIENT_AVAIL:
-
-342                //  estimate         of  the     number       of     additional    transient         objects    that
-
-343                //  could    be      loaded      into    TPM      RAM
-
-344                *value    =  ObjectCapGetTransientAvail();
-
-345                break;
-
-346  case          TPM_PT_HR_PERSISTENT:
-
-347                //  number       of  persistent          objects          currently      loaded  into     TPM
-
-348                //  NV   memory
-
-349                *value    =  NvCapGetPersistentNumber();
-
-350                break;
-
-351  case          TPM_PT_HR_PERSISTENT_AVAIL:
-
-352                //  number       of  additional          persistent       objects        that    could    be   loaded
-
-353                //  into     NV  memory
-
-354                *value    =  NvCapGetPersistentAvail();
-
-355                break;
-
-356  case          TPM_PT_NV_COUNTERS:
-
-357                //  number       of  defined         NV  indexes          that  have     NV  TPMA_NV_COUNTER
-
-358                //  attribute        SET
-
-359                *value    =  NvCapGetCounterNumber();
-
-360                break;
-
-361  case          TPM_PT_NV_COUNTERS_AVAIL:
-
-362                //  number       of  additional          NV   indexes     that     can       be  defined  with   their
-
-363                //  TPMA_NV_COUNTER              attribute           SET
-
-364                *value    =  NvCapGetCounterAvail();
-
-365                break;
-
-366  case          TPM_PT_ALGORITHM_SET:
-
-367                //  region       code    for     the     TPM
-
-368                *value    =  gp.algorithmSet;
-
-369                break;
-
-370
-
-371  case          TPM_PT_LOADED_CURVES:
-
+310                               flags.orderly          =  SET;
+             
+311          
+             
+312                        //  Note:    Different           compilers           may  require     a  different       method  to    cast
+             
+313                        //  a   bit  field       structure       to       a  UINT32.
+             
+314                        *value    =  *   (UINT32         *)   &flags;
+             
+315                        break;
+             
+316          }
+             
+317          case          TPM_PT_HR_NV_INDEX:
+             
+318                        //  number       of  NV      indexes     currently        defined
+             
+319                        *value    =  NvCapGetIndexNumber();
+             
+320                        break;
+             
+321          case          TPM_PT_HR_LOADED:
+             
+322                        //  number       of  authorization            sessions          currently        loaded  into   TPM
+             
+323                        //  RAM
+             
+324                        *value    =  SessionCapGetLoadedNumber();
+             
+325                        break;
+             
+326          case          TPM_PT_HR_LOADED_AVAIL:
+             
+327                        //  number       of  additional          authorization          sessions,        of  any  type,
+             
+328                        //  that     could       be   loaded     into        TPM  RAM
+             
+329                        *value    =  SessionCapGetLoadedAvail();
+             
+330                        break;
+             
+331          case          TPM_PT_HR_ACTIVE:
+             
+332                        //  number       of  active      authorization            sessions       currently       being
+             
+333                        //  tracked      by      the  TPM
+             
+334                        *value    =  SessionCapGetActiveNumber();
+             
+335                        break;
+             
+336          case          TPM_PT_HR_ACTIVE_AVAIL:
+             
+337                        //  number       of  additional          authorization          sessions,        of  any  type,
+             
+338                        //  that     could       be   created
+             
+339                        *value    =  SessionCapGetActiveAvail();
+             
+340                        break;
+             
+341          case          TPM_PT_HR_TRANSIENT_AVAIL:
+             
+342                        //  estimate         of  the     number       of     additional    transient         objects    that
+             
+343                        //  could    be      loaded      into    TPM      RAM
+             
+344                        *value    =  ObjectCapGetTransientAvail();
+             
+345                        break;
+             
+346          case          TPM_PT_HR_PERSISTENT:
+             
+347                        //  number       of  persistent          objects          currently      loaded  into     TPM
+             
+348                        //  NV   memory
+             
+349                        *value    =  NvCapGetPersistentNumber();
+             
+350                        break;
+             
+351          case          TPM_PT_HR_PERSISTENT_AVAIL:
+             
+352                        //  number       of  additional          persistent       objects        that    could    be   loaded
+             
+353                        //  into     NV  memory
+             
+354                        *value    =  NvCapGetPersistentAvail();
+             
+355                        break;
+             
+356          case          TPM_PT_NV_COUNTERS:
+             
+357                        //  number       of  defined         NV  indexes          that  have     NV  TPMA_NV_COUNTER
+             
+358                        //  attribute        SET
+             
+359                        *value    =  NvCapGetCounterNumber();
+             
+360                        break;
+             
+361          case          TPM_PT_NV_COUNTERS_AVAIL:
+             
+362                        //  number       of  additional          NV   indexes     that     can       be  defined  with   their
+             
+363                        //  TPMA_NV_COUNTER              attribute           SET
+             
+364                        *value    =  NvCapGetCounterAvail();
+             
+365                        break;
+             
+366          case          TPM_PT_ALGORITHM_SET:
+             
+367                        //  region       code    for     the     TPM
+             
+368                        *value    =  gp.algorithmSet;
+             
+369                        break;
+             
+370          
+             
+371          case          TPM_PT_LOADED_CURVES:
+             
 372  #ifdef        TPM_ALG_ECC
-
-373                //  number       of  loaded      ECC     curves
-
-374                *value    =  CryptCapGetEccCurveNumber();
-
+             
+373                        //  number       of  loaded      ECC     curves
+             
+374                        *value    =  CryptCapGetEccCurveNumber();
+             
 375  #else   //    TPM_ALG_ECC
 
      Family "2.0"                                           TCG Published                                                  Page 263
@@ -32369,135 +32141,135 @@ Level 00 Revision 01.16      Copyright 
      October 30, 2014                                          Copyright © TCG 2006-2014                        Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                                Trusted Platform Module Library
 
-153          break;
+153                break;
 
-154
+154        
 
-155  case       TPM_CC_GetCapability:
+155        case       TPM_CC_GetCapability:
 
-156          //    make       sure         that        the    size      of   the  command       is   exactly     the   size
+156                //    make       sure         that        the    size      of   the  command       is   exactly     the   size
 
-157          //    returned             for         the     capability,          property,      and   count
+157                //    returned             for         the     capability,          property,      and   count
 
-158          if(              header.size!=                   (10    +   (3   *   sizeof(UINT32)))
+158                if(              header.size!=                   (10    +   (3   *   sizeof(UINT32)))
 
-159                           //     also           verify       that    this     is  requesting       TPM   properties
+159                                 //     also           verify       that    this     is  requesting       TPM   properties
 
-160                ||                   (UINT32_Unmarshal(&capability,                          &inRequest,
+160                      ||                   (UINT32_Unmarshal(&capability,                          &inRequest,
 
-161                                                                          (INT32     *)&inRequestSize)
+161                                                                                (INT32     *)&inRequestSize)
 
-162                           !=        TPM_RC_SUCCESS)
+162                                 !=        TPM_RC_SUCCESS)
 
-163                ||      (capability                   !=   TPM_CAP_TPM_PROPERTIES)
+163                      ||      (capability                   !=   TPM_CAP_TPM_PROPERTIES)
 
-164                ||                   (UINT32_Unmarshal(&pt,                        &inRequest,      (INT32     *)&inRequestSize)
+164                      ||                   (UINT32_Unmarshal(&pt,                        &inRequest,      (INT32     *)&inRequestSize)
 
-165                           !=     TPM_RC_SUCCESS)
+165                                 !=     TPM_RC_SUCCESS)
 
-166                ||                   (UINT32_Unmarshal(&count,                       &inRequest,         (INT32     *)&inRequestSize)
+166                      ||                   (UINT32_Unmarshal(&count,                       &inRequest,         (INT32     *)&inRequestSize)
 
-167                           !=     TPM_RC_SUCCESS)
+167                                 !=     TPM_RC_SUCCESS)
 
-168                )
+168                      )
 
-169
+169        
 
-170                goto        FailureModeReturn;
+170                      goto        FailureModeReturn;
 
-171
+171        
 
-172          //    If   in     failure                 mode   because        of   an  unrecoverable         read  error,       and  the
+172                //    If   in     failure                 mode   because        of   an  unrecoverable         read  error,       and  the
 
-173          //    property             is       0     and   the     count    is  0,    then    this   is   an   indication     to
+173                //    property             is       0     and   the     count    is  0,    then    this   is   an   indication     to
 
-174          //    re-manufacture                      the    TPM.      Do   the  re-manufacture           but   stay  in    failure
+174                //    re-manufacture                      the    TPM.      Do   the  re-manufacture           but   stay  in    failure
 
-175          //    mode       until           the      TPM    is     reset.
+175                //    mode       until           the      TPM    is     reset.
 
-176          //    Note:       this           behavior           is  not     required      by   the   specification        and  it  is
+176                //    Note:       this           behavior           is  not     required      by   the   specification        and  it  is
 
-177          //    OK   to     leave             the     TPM     permanently          bricked   due    to   an   unrecoverable      NV
+177                //    OK   to     leave             the     TPM     permanently          bricked   due    to   an   unrecoverable      NV
 
-178          //    error.
+178                //    error.
 
-179          if(   count          ==       0     &&    pt    ==   0  &&     s_failCode      ==  FATAL_ERROR_NV_UNRECOVERABLE)
+179                if(   count          ==       0     &&    pt    ==   0  &&     s_failCode      ==  FATAL_ERROR_NV_UNRECOVERABLE)
 
-180          {
+180                {
 
-181                g_manufactured                        =   FALSE;
+181                      g_manufactured                        =   FALSE;
 
-182                TPM_Manufacture(0);
+182                      TPM_Manufacture(0);
 
-183          }
+183                }
 
-184
+184        
 
-185          if(count          >     0)
+185                if(count          >     0)
 
-186                count          =     1;
+186                      count          =     1;
 
-187          else      if(pt         >     TPM_PT_FIRMWARE_VERSION_2)
+187                else      if(pt         >     TPM_PT_FIRMWARE_VERSION_2)
 
-188                count          =     0;
+188                      count          =     0;
 
-189          if(pt      <     TPM_PT_MANUFACTURER)
+189                if(pt      <     TPM_PT_MANUFACTURER)
 
-190                pt      =   TPM_PT_MANUFACTURER;
+190                      pt      =   TPM_PT_MANUFACTURER;
 
-191
+191        
 
-192          //    set     up     for         return
+192                //    set     up     for         return
 
-193          buffer        =   &response[10];
+193                buffer        =   &response[10];
 
-194          //    if   the       request              was    for    a   PT   less    than     the   last   one
+194                //    if   the       request              was    for    a   PT   less    than     the   last   one
 
-195          //    then       we     indicate               more,    otherwise,         not.
+195                //    then       we     indicate               more,    otherwise,         not.
 
-196          if(pt      <     TPM_PT_FIRMWARE_VERSION_2)
+196                if(pt      <     TPM_PT_FIRMWARE_VERSION_2)
 
-197                *buffer++                  =     YES;
+197                      *buffer++                  =     YES;
 
-198          else
+198                else
 
-199                *buffer++                  =     NO;
+199                      *buffer++                  =     NO;
 
-200
+200        
 
-201          marshalSize                =     1;
+201                marshalSize                =     1;
 
-202
+202        
 
-203          //    indicate             the         capability          type
+203                //    indicate             the         capability          type
 
-204          marshalSize                +=       MarshalUint32(capability,                     &buffer);
+204                marshalSize                +=       MarshalUint32(capability,                     &buffer);
 
-205          //    indicate             the         number       of  values       that  are     being  returned        (0  or   1)
+205                //    indicate             the         number       of  values       that  are     being  returned        (0  or   1)
 
-206          marshalSize                +=       MarshalUint32(count,                 &buffer);
+206                marshalSize                +=       MarshalUint32(count,                 &buffer);
 
-207          //    indicate             the         property
+207                //    indicate             the         property
 
-208          marshalSize                +=       MarshalUint32(pt,                &buffer);
+208                marshalSize                +=       MarshalUint32(pt,                &buffer);
 
-209
+209        
 
-210          if(count          >     0)
+210                if(count          >     0)
 
-211                switch            (pt)           {
+211                      switch            (pt)           {
 
-212                case        TPM_PT_MANUFACTURER:
+212                      case        TPM_PT_MANUFACTURER:
 
-213                //      the       vendor            ID    unique      to   each    TPM   manufacturer
+213                      //      the       vendor            ID    unique      to   each    TPM   manufacturer
 
 214  #ifdef  MANUFACTURER
 
-215                pt      =   *(UINT32*)MANUFACTURER;
+215                      pt      =   *(UINT32*)MANUFACTURER;
 
 216  #else
 
-217                pt      =   0;
+217                      pt      =   0;
 
 218  #endif
 
@@ -32506,137 +32278,137 @@ Level 00 Revision 01.16      Copyright 
      Level 00 Revision 01.16                                  Copyright © TCG 2006-2014                                         October 30, 2014
      Trusted Platform Module Library                                                                        Part 4: Supporting Routines
 
-219                  break;
+219                              break;
 
-220          case     TPM_PT_VENDOR_STRING_1:
+220                      case     TPM_PT_VENDOR_STRING_1:
 
-221                  //   the       first   four    characters         of     the     vendor  ID    string
+221                              //   the       first   four    characters         of     the     vendor  ID    string
 
 222  #ifdef  VENDOR_STRING_1
 
-223                  pt   =     *(UINT32*)VENDOR_STRING_1;
+223                              pt   =     *(UINT32*)VENDOR_STRING_1;
 
 224  #else
 
-225                  pt   =     0;
+225                              pt   =     0;
 
 226  #endif
 
-227                  break;
+227                              break;
 
-228          case     TPM_PT_VENDOR_STRING_2:
+228                      case     TPM_PT_VENDOR_STRING_2:
 
-229                  //   the       second  four       characters         of  the     vendor  ID    string
+229                              //   the       second  four       characters         of  the     vendor  ID    string
 
 230  #ifdef  VENDOR_STRING_2
 
-231                  pt   =     *(UINT32*)VENDOR_STRING_2;
+231                              pt   =     *(UINT32*)VENDOR_STRING_2;
 
 232  #else
 
-233                  pt   =     0;
+233                              pt   =     0;
 
 234  #endif
 
-235                  break;
+235                              break;
 
-236          case     TPM_PT_VENDOR_STRING_3:
+236                      case     TPM_PT_VENDOR_STRING_3:
 
-237                  //   the       third   four    characters         of     the     vendor  ID    string
+237                              //   the       third   four    characters         of     the     vendor  ID    string
 
 238  #ifdef  VENDOR_STRING_3
 
-239                  pt   =     *(UINT32*)VENDOR_STRING_3;
+239                              pt   =     *(UINT32*)VENDOR_STRING_3;
 
 240  #else
 
-241                  pt   =     0;
+241                              pt   =     0;
 
 242  #endif
 
-243                  break;
+243                              break;
 
-244          case     TPM_PT_VENDOR_STRING_4:
+244                      case     TPM_PT_VENDOR_STRING_4:
 
-245                  //   the       fourth  four       characters         of  the     vendor  ID    string
+245                              //   the       fourth  four       characters         of  the     vendor  ID    string
 
 246  #ifdef  VENDOR_STRING_4
 
-247                  pt   =     *(UINT32*)VENDOR_STRING_4;
+247                              pt   =     *(UINT32*)VENDOR_STRING_4;
 
 248  #else
 
-249                  pt   =     0;
+249                              pt   =     0;
 
 250  #endif
 
 251
 
-252                  break;
+252                              break;
 
-253          case     TPM_PT_VENDOR_TPM_TYPE:
+253                      case     TPM_PT_VENDOR_TPM_TYPE:
 
-254                  //   vendor-defined            value      indicating          the  TPM   model
+254                              //   vendor-defined            value      indicating          the  TPM   model
 
-255                  //   We    just      make  up     a  number       here
+255                              //   We    just      make  up     a  number       here
 
-256                  pt   =     1;
+256                              pt   =     1;
 
-257                  break;
+257                              break;
 
-258          case     TPM_PT_FIRMWARE_VERSION_1:
+258                      case     TPM_PT_FIRMWARE_VERSION_1:
 
-259                  //   the       more   significant         32-bits        of   a  vendor-specific        value
+259                              //   the       more   significant         32-bits        of   a  vendor-specific        value
 
-260                  //   indicating        the     version        of  the    firmware
+260                              //   indicating        the     version        of  the    firmware
 
 261  #ifdef  FIRMWARE_V1
 
-262                  pt   =     FIRMWARE_V1;
+262                              pt   =     FIRMWARE_V1;
 
 263  #else
 
-264                  pt   =     0;
+264                              pt   =     0;
 
 265  #endif
 
-266                  break;
+266                              break;
 
-267          default:           //  TPM_PT_FIRMWARE_VERSION_2:
+267                      default:           //  TPM_PT_FIRMWARE_VERSION_2:
 
-268                  //   the       less   significant         32-bits        of   a  vendor-specific        value
+268                              //   the       less   significant         32-bits        of   a  vendor-specific        value
 
-269                  //   indicating        the     version        of  the    firmware
+269                              //   indicating        the     version        of  the    firmware
 
 270  #ifdef  FIRMWARE_V2
 
-271                  pt   =     FIRMWARE_V2;
+271                              pt   =     FIRMWARE_V2;
 
 272  #else
 
-273                  pt   =     0;
+273                              pt   =     0;
 
 274  #endif
 
-275                  break;
+275                              break;
 
-276          }
+276                      }
 
-277          marshalSize            +=    MarshalUint32(pt,            &buffer);
+277                      marshalSize            +=    MarshalUint32(pt,            &buffer);
 
-278          break;
+278                      break;
 
-279  default:         //     default       for  switch         (cc)
+279              default:         //     default       for  switch         (cc)
 
-280          goto     FailureModeReturn;
+280                      goto     FailureModeReturn;
 
-281  }
+281              }
 
-282  //      Now  do     the    header
+282              //      Now  do     the    header
 
-283  buffer       =   response;
+283              buffer       =   response;
 
-284  marshalSize             =  marshalSize         +     10;  //    Add   the     header     size  to  the
+284              marshalSize             =  marshalSize         +     10;  //    Add   the     header     size  to  the
 
      Page 270                                                  TCG Published                                            Family "2.0"
 
@@ -40573,55 +40345,55 @@ Level 00 Revision 01.16      Copyright 
     checked (indexed using the algorithm ID). If the bit is SET, then the test function should be called.
 
 1   #include        "Global.h"
-
+    
 2   #include        "CryptoEngine.h"
-
+    
 3   #include        "InternalRoutines.h"
-
+    
 4   #include        "AlgorithmCap_fp.h"
 
-    10.4.2    Functions
+   10.4.2    Functions
 
-    10.4.2.1       RunSelfTest()
+   10.4.2.1       RunSelfTest()
 
-    Local function to run self-test
+   Local function to run self-test
 
 5   static    TPM_RC
-
+    
 6   CryptRunSelfTests(
-
+    
 7      ALGORITHM_VECTOR                *toTest                //     IN:  the   vector      of  the  algorithms     to  test
-
+    
 8      )
-
+    
 9   {
-
+    
 10     TPM_ALG_ID                      alg;
-
-11
-
+    
+11  
+    
 12     //     For   each  of  the    algorithms    that       are    in   the   toTestVecor,    need  to  run    a
-
+    
 13     //     test
-
+    
 14     for(alg      =    TPM_ALG_FIRST;      alg   <=     TPM_ALG_LAST;         alg++)
-
+    
 15     {
-
+    
 16            if(TEST_BIT(alg,         *toTest))
-
+    
 17            {
-
+    
 18                  TPM_RC                 result      =  CryptTestAlgorithm(alg,               toTest);
-
+    
 19                  if(result      !=  TPM_RC_SUCCESS)
-
+    
 20                        return     result;
-
+    
 21            }
-
+    
 22     }
-
+    
 23     return       TPM_RC_SUCCESS;
 
 24  }
@@ -40791,65 +40563,65 @@ Level 00 Revision 01.16      Copyright 
      Trusted Platform Module Library                                                                             Part 4: Supporting Routines
 
 82   }
-
-     10.4.2.4       CryptInitializeToTest()
-
-     This function will initialize the data structures for testing all the algorithms.                           This should not        be  called
-
-     unless CryptAlgsSetImplemented() has been called
-
+     
+      10.4.2.4       CryptInitializeToTest()
+     
+      This function will initialize the data structures for testing all the algorithms.                           This should not        be  called
+     
+      unless CryptAlgsSetImplemented() has been called
+     
 83   void
-
+     
 84   CryptInitializeToTest(
-
+     
 85         void
-
+     
 86         )
-
+     
 87   {
-
+     
 88         MemoryCopy(g_toTest,
-
+     
 89                            g_implementedAlgorithms,
-
+     
 90                            sizeof(g_toTest),
-
+     
 91                            sizeof(g_toTest));
-
+     
 92         //  Setting        the  algorithm        to  null        causes     the  test      function       to  just      clear
-
+     
 93         //  out     any    algorithms       for   which       there     is   no  test.
-
+     
 94         CryptTestAlgorithm(TPM_ALG_ERROR,                         &g_toTest);
-
-95
-
+     
+95   
+     
 96         return;
-
+     
 97   }
-
-     10.4.2.5       CryptTestAlgorithm()
-
-     Only point of contact with the actual self tests. If a self-test fails, there is no return and the TPM goes into
-
-     failure mode. The call to TestAlgorithm() uses an algorithms selector and a bit vector. When the test is
-
-     run, the corresponding bit in toTest and in g_toTest is CLEAR. If toTest is NULL, then only the bit in
-
-     g_toTest    is    CLEAR.          There   is   a   special      case      for  the     call    to   TestAlgorithm().         When      alg  is
-
-     TPM_ALG_ERROR, TestAlgorithm() will CLEAR any bit in toTest for which it has no test. This allows the
-
-     knowledge about which algorithms have test to be accessed through the interface that provides the test.
-
-     Error Returns                             Meaning
-
-     TPM_RC_SUCCESS                            test complete
-
-     TPM_RC_CANCELED                           test was canceled
-
+     
+      10.4.2.5       CryptTestAlgorithm()
+     
+      Only point of contact with the actual self tests. If a self-test fails, there is no return and the TPM goes into
+     
+      failure mode. The call to TestAlgorithm() uses an algorithms selector and a bit vector. When the test is
+     
+      run, the corresponding bit in toTest and in g_toTest is CLEAR. If toTest is NULL, then only the bit in
+     
+      g_toTest    is    CLEAR.          There   is   a   special      case      for  the     call    to   TestAlgorithm().         When      alg  is
+     
+      TPM_ALG_ERROR, TestAlgorithm() will CLEAR any bit in toTest for which it has no test. This allows the
+     
+      knowledge about which algorithms have test to be accessed through the interface that provides the test.
+     
+      Error Returns                             Meaning
+     
+      TPM_RC_SUCCESS                            test complete
+     
+      TPM_RC_CANCELED                           test was canceled
+     
 98   LIB_EXPORT
-
+     
 99   TPM_RC
 
 100  CryptTestAlgorithm(
@@ -44339,7 +44111,7 @@ Level 00 Revision 01.16      Copyright 
 
     B.6.2.     Includes and Locals
 
-1      #include  "OsslCryptoEngine.h"
+1   #include  "OsslCryptoEngine.h"
 
 2   static     void  Trap(const  char  *function,   int  line,         int  code);
 
@@ -44753,7 +44525,7 @@ Level 00 Revision 01.16      Copyright 
 
 91  }
 
-92  #endif   //%
+92  
 
     Family "2.0"                                TCG Published                                        Page 379
 
@@ -46578,7 +46350,7 @@ Level 00 Revision 01.16      Copyright 
 
     This file should be included by the library hash module.
 
-1        const  HASH_INFO    g_hashData[HASH_COUNT            +  1]  =  {
+1   const  HASH_INFO    g_hashData[HASH_COUNT            +  1]  =  {
 
 2   #ifdef TPM_ALG_SHA1
 
@@ -48807,137 +48579,137 @@ Level 00 Revision 01.16      Copyright 
     October 30, 2014                      Copyright © TCG 2006-2014                        Level 00 Revision 01.16
     Part 4: Supporting Routines                                                                                            Trusted Platform Module Library
 
-24  if(context            ==     NULL)
-
-25        FAIL(FATAL_ERROR_ALLOCATION);
-
-26  BN_CTX_start(context);
-
-27  bnE   =     BN_CTX_get(context);
-
-28  bnD   =     BN_CTX_get(context);
-
-29  bnN   =     BN_CTX_get(context);
-
-30  bnP   =     BN_CTX_get(context);
-
-31  bnPhi       =     BN_CTX_get(context);
-
-32  bnQ   =     BN_CTX_get(context);
-
-33  bnQr     =     BN_CTX_get(context);
-
-34
-
-35  if(bnQr           ==  NULL)
-
-36        FAIL(FATAL_ERROR_ALLOCATION);
-
-37
-
-38  //   Assume           the    size      of    the       public        key      value     is     within         range
-
-39  pAssert(key->publicKey->size                                  <=     MAX_RSA_KEY_BYTES);
-
-40
-
-41  if(         BN_bin2bn(key->publicKey->buffer,                                      key->publicKey->size,                          bnN)   ==  NULL
-
-42       ||     BN_bin2bn(key->privateKey->buffer,                                      key->privateKey->size,                           bnP)    ==  NULL)
-
-43
-
-44        FAIL(FATAL_ERROR_INTERNAL);
-
-45
-
-46  //   If     P     size     is     not     1/2    of    n      size,       then     this     is     not     a     valid        value     for  this
-
-47  //   implementation.                   This      will         also       catch     the     case     were         P     is  input     as     zero.
-
-48  //   This         generates         a     return       rather            than   an     assert       because            the    key    being       loaded
-
-49  //   might        be     SW    generated            and       wrong.
-
-50  if(BN_num_bits(bnP)                       <  BN_num_bits(bnN)/2)
-
-51  {
-
-52        retVal          =    CRYPT_PARAMETER;
-
-53        goto        Cleanup;
-
-54  }
-
-55  //   Get       q  =   n/p;
-
-56  if   (BN_div(bnQ,                 bnQr,      bnN,      bnP,          context)       !=     1)
-
-57        FAIL(FATAL_ERROR_INTERNAL);
-
-58
-
-59  //   If     there        is    a   remainder,              then      this      is   not     a   valid         n
-
-60  if(BN_num_bytes(bnQr)                        !=     0  ||     BN_num_bits(bnQ)                  !=     BN_num_bits(bnP))
-
-61  {
-
-62        retVal          =    CRYPT_PARAMETER;                               //   problem         may     be     recoverable
-
-63        goto        Cleanup;
-
-64  }
-
-65  //   Get       compute         Phi     =     (p  -     1)(q       -  1)   =    pq   -   p   -   q   +   1     =     n  -   p  -   q  +   1
-
-66  if(         BN_copy(bnPhi,                   bnN)      ==     NULL
-
-67       ||     !BN_sub(bnPhi,                   bnPhi,        bnP)
-
-68       ||     !BN_sub(bnPhi,                   bnPhi,        bnQ)
-
-69       ||     !BN_add_word(bnPhi,                        1))
-
-70        FAIL(FATAL_ERROR_INTERNAL);
-
-71
-
-72  //   Compute          the      multiplicative                 inverse
-
-73  BN_set_word(bnE,                   key->exponent);
-
-74  if(BN_mod_inverse(bnD,                           bnE,      bnPhi,         context)         ==   NULL)
-
-75  {
-
-76        //       Going       to     assume         that      the       error     is   caused         by   a     bad
-
-77        //       set    of     parameters.               Specifically,               an   exponent           that        is
-
-78        //       not    compatible             with      the        primes.       In     an   implementation                    that
-
-79        //       has    better        visibility                to     the  error        codes,       this         might        be
-
-80        //       refined         so   that         failures            in   the   library         would         return
-
-81        //       a  more       informative               value.            Should     not     assume         here        that
-
-82        //       the    error        codes         will      remain         unchanged.
-
-83
-
-84        retVal          =    CRYPT_PARAMETER;
-
-85        goto        Cleanup;
-
-86  }
-
-87
-
-88  fill     =     key->publicKey->size                        -  BN_num_bytes(bnD);
-
-89  BN_bn2bin(bnD,                 &key->privateKey->buffer[fill]);
+24        if(context            ==     NULL)
+          
+25              FAIL(FATAL_ERROR_ALLOCATION);
+          
+26        BN_CTX_start(context);
+          
+27        bnE   =     BN_CTX_get(context);
+          
+28        bnD   =     BN_CTX_get(context);
+          
+29        bnN   =     BN_CTX_get(context);
+          
+30        bnP   =     BN_CTX_get(context);
+          
+31        bnPhi       =     BN_CTX_get(context);
+          
+32        bnQ   =     BN_CTX_get(context);
+          
+33        bnQr     =     BN_CTX_get(context);
+          
+34        
+          
+35        if(bnQr           ==  NULL)
+          
+36              FAIL(FATAL_ERROR_ALLOCATION);
+          
+37        
+          
+38        //   Assume           the    size      of    the       public        key      value     is     within         range
+          
+39        pAssert(key->publicKey->size                                  <=     MAX_RSA_KEY_BYTES);
+          
+40        
+          
+41        if(         BN_bin2bn(key->publicKey->buffer,                                      key->publicKey->size,                          bnN)   ==  NULL
+          
+42             ||     BN_bin2bn(key->privateKey->buffer,                                      key->privateKey->size,                           bnP)    ==  NULL)
+          
+43        
+          
+44              FAIL(FATAL_ERROR_INTERNAL);
+          
+45        
+          
+46        //   If     P     size     is     not     1/2    of    n      size,       then     this     is     not     a     valid        value     for  this
+          
+47        //   implementation.                   This      will         also       catch     the     case     were         P     is  input     as     zero.
+          
+48        //   This         generates         a     return       rather            than   an     assert       because            the    key    being       loaded
+          
+49        //   might        be     SW    generated            and       wrong.
+          
+50        if(BN_num_bits(bnP)                       <  BN_num_bits(bnN)/2)
+          
+51        {
+          
+52              retVal          =    CRYPT_PARAMETER;
+          
+53              goto        Cleanup;
+          
+54        }
+          
+55        //   Get       q  =   n/p;
+          
+56        if   (BN_div(bnQ,                 bnQr,      bnN,      bnP,          context)       !=     1)
+          
+57              FAIL(FATAL_ERROR_INTERNAL);
+          
+58        
+          
+59        //   If     there        is    a   remainder,              then      this      is   not     a   valid         n
+          
+60        if(BN_num_bytes(bnQr)                        !=     0  ||     BN_num_bits(bnQ)                  !=     BN_num_bits(bnP))
+          
+61        {
+          
+62              retVal          =    CRYPT_PARAMETER;                               //   problem         may     be     recoverable
+          
+63              goto        Cleanup;
+          
+64        }
+          
+65        //   Get       compute         Phi     =     (p  -     1)(q       -  1)   =    pq   -   p   -   q   +   1     =     n  -   p  -   q  +   1
+          
+66        if(         BN_copy(bnPhi,                   bnN)      ==     NULL
+          
+67             ||     !BN_sub(bnPhi,                   bnPhi,        bnP)
+          
+68             ||     !BN_sub(bnPhi,                   bnPhi,        bnQ)
+          
+69             ||     !BN_add_word(bnPhi,                        1))
+          
+70              FAIL(FATAL_ERROR_INTERNAL);
+          
+71        
+          
+72        //   Compute          the      multiplicative                 inverse
+          
+73        BN_set_word(bnE,                   key->exponent);
+          
+74        if(BN_mod_inverse(bnD,                           bnE,      bnPhi,         context)         ==   NULL)
+          
+75        {
+          
+76              //       Going       to     assume         that      the       error     is   caused         by   a     bad
+          
+77              //       set    of     parameters.               Specifically,               an   exponent           that        is
+          
+78              //       not    compatible             with      the        primes.       In     an   implementation                    that
+          
+79              //       has    better        visibility                to     the  error        codes,       this         might        be
+          
+80              //       refined         so   that         failures            in   the   library         would         return
+          
+81              //       a  more       informative               value.            Should     not     assume         here        that
+          
+82              //       the    error        codes         will      remain         unchanged.
+          
+83        
+          
+84              retVal          =    CRYPT_PARAMETER;
+          
+85              goto        Cleanup;
+          
+86        }
+          
+87        
+          
+88        fill     =     key->publicKey->size                        -  BN_num_bytes(bnD);
+          
+89        BN_bn2bin(bnD,                 &key->privateKey->buffer[fill]);
 
     Family "2.0"                                                         TCG Published                                                                 Page 417
 
@@ -49063,137 +48835,137 @@ Level 00 Revision 01.16      Copyright 
      October 30, 2014                             Copyright © TCG 2006-2014                                Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                                      Trusted Platform Module Library
 
-138  bnE   =     BN_CTX_get(context);                            //    public         exponent             (e)
-
-139  bnD   =     BN_CTX_get(context);                            //    private         exponent               (d)
-
-140  bnN   =     BN_CTX_get(context);                            //    public         modulus           (n)
-
-141  bnP   =     BN_CTX_get(context);                            //    prime1         (p)
-
-142  bnPhi       =  BN_CTX_get(context);                         //    (p-1)(q-1)
-
-143  bnQ   =     BN_CTX_get(context);                            //    prime2         (q)
-
-144  bnQr     =     BN_CTX_get(context);                         //    n     mod   p
-
-145
-
-146  if(bnQr        ==    NULL)
-
-147        FAIL(FATAL_ERROR_ALLOCATION);
-
-148
-
-149  if(BN_bin2bn(prime1->buffer,                          prime1->size,               bnP)        ==      NULL)
-
-150        FAIL(FATAL_ERROR_INTERNAL);
-
-151
-
-152  //   If     prime2       is     provided,       then     compute        n
-
-153  if(prime2           !=   NULL)
-
-154  {
-
-155        //       Two   primes         provided      so     use    them    to       compute           n
-
-156        if(BN_bin2bn(prime2->buffer,                            prime2->size,                bnQ)          ==   NULL)
-
-157                 FAIL(FATAL_ERROR_INTERNAL);
-
-158
-
-159        //       Make     sure    that      the   sizes       of    the   primes             are     compatible
-
-160        if(BN_num_bits(bnQ)                   !=    BN_num_bits(bnP))
-
-161        {
-
-162                 retVal        =  CRYPT_PARAMETER;
-
-163                 goto      Cleanup;
-
-164        }
-
-165        //       Multiply         the     primes    to     get    the     public          modulus
-
-166
-
-167        if(BN_mul(bnN,                 bnP,   bnQ,      context)          !=    1)
-
-168                 FAIL(FATAL_ERROR_INTERNAL);
-
-169
-
-170        //       if   the     space       provided      for     the       public       modulus             is   large    enough,
-
-171        //       save     the     created     value
-
-172        if(BN_num_bits(bnN)                   !=    (publicKey->size                   *     8))
-
-173        {
-
-174                 retVal        =  CRYPT_PARAMETER;
-
-175                 goto      Cleanup;
-
-176        }
-
-177        BN_bn2bin(bnN,                 publicKey->buffer);
-
-178  }
-
-179  else
-
-180  {
-
-181        //       One   prime      provided        so    find      the     second          prime         by     division
-
-182        BN_bin2bn(publicKey->buffer,                            publicKey->size,                     bnN);
-
-183
-
-184        //       Get   q   =   n/p;
-
-185        if(BN_div(bnQ,                 bnQr,     bnN,      bnP,     context)           !=    1)
-
-186                 FAIL(FATAL_ERROR_INTERNAL);
-
-187
-
-188        //       If   there       is   a  remainder,          then        this     is     not     a     valid      n
-
-189        if(BN_num_bytes(bnQr)                     !=    0  ||     BN_num_bits(bnQ)                      !=     BN_num_bits(bnP))
-
-190        {
-
-191                 retVal        =  CRYPT_PARAMETER;                        //       problem           may       be  recoverable
-
-192                 goto      Cleanup;
-
-193        }
-
-194  }
-
-195  //   Get       compute       Phi     =  (p  -   1)(q     -    1)     =  pq    -   p     -  q    +     1   =   n  -  p  -  q  +  1
-
-196  BN_copy(bnPhi,               bnN);
-
-197  BN_sub(bnPhi,               bnPhi,      bnP);
-
-198  BN_sub(bnPhi,               bnPhi,      bnQ);
-
-199  BN_add_word(bnPhi,                   1);
-
-200  //   Compute         the     multiplicative              inverse
-
-201  BN_set_word(bnE,                exponent);
-
-202  if(BN_mod_inverse(bnD,                      bnE,    bnPhi,        context)           ==    NULL)
-
-203  {
+138     bnE   =     BN_CTX_get(context);                            //    public         exponent             (e)
+        
+139     bnD   =     BN_CTX_get(context);                            //    private         exponent               (d)
+        
+140     bnN   =     BN_CTX_get(context);                            //    public         modulus           (n)
+        
+141     bnP   =     BN_CTX_get(context);                            //    prime1         (p)
+        
+142     bnPhi       =  BN_CTX_get(context);                         //    (p-1)(q-1)
+        
+143     bnQ   =     BN_CTX_get(context);                            //    prime2         (q)
+        
+144     bnQr     =     BN_CTX_get(context);                         //    n     mod   p
+        
+145     
+        
+146     if(bnQr        ==    NULL)
+        
+147           FAIL(FATAL_ERROR_ALLOCATION);
+        
+148     
+        
+149     if(BN_bin2bn(prime1->buffer,                          prime1->size,               bnP)        ==      NULL)
+        
+150           FAIL(FATAL_ERROR_INTERNAL);
+        
+151     
+        
+152     //   If     prime2       is     provided,       then     compute        n
+        
+153     if(prime2           !=   NULL)
+        
+154     {
+        
+155           //       Two   primes         provided      so     use    them    to       compute           n
+        
+156           if(BN_bin2bn(prime2->buffer,                            prime2->size,                bnQ)          ==   NULL)
+        
+157                    FAIL(FATAL_ERROR_INTERNAL);
+        
+158     
+        
+159           //       Make     sure    that      the   sizes       of    the   primes             are     compatible
+        
+160           if(BN_num_bits(bnQ)                   !=    BN_num_bits(bnP))
+        
+161           {
+        
+162                    retVal        =  CRYPT_PARAMETER;
+        
+163                    goto      Cleanup;
+        
+164           }
+        
+165           //       Multiply         the     primes    to     get    the     public          modulus
+        
+166     
+        
+167           if(BN_mul(bnN,                 bnP,   bnQ,      context)          !=    1)
+        
+168                    FAIL(FATAL_ERROR_INTERNAL);
+        
+169     
+        
+170           //       if   the     space       provided      for     the       public       modulus             is   large    enough,
+        
+171           //       save     the     created     value
+        
+172           if(BN_num_bits(bnN)                   !=    (publicKey->size                   *     8))
+        
+173           {
+        
+174                    retVal        =  CRYPT_PARAMETER;
+        
+175                    goto      Cleanup;
+        
+176           }
+        
+177           BN_bn2bin(bnN,                 publicKey->buffer);
+        
+178     }
+        
+179     else
+        
+180     {
+        
+181           //       One   prime      provided        so    find      the     second          prime         by     division
+        
+182           BN_bin2bn(publicKey->buffer,                            publicKey->size,                     bnN);
+        
+183     
+        
+184           //       Get   q   =   n/p;
+        
+185           if(BN_div(bnQ,                 bnQr,     bnN,      bnP,     context)           !=    1)
+        
+186                    FAIL(FATAL_ERROR_INTERNAL);
+        
+187     
+        
+188           //       If   there       is   a  remainder,          then        this     is     not     a     valid      n
+        
+189           if(BN_num_bytes(bnQr)                     !=    0  ||     BN_num_bits(bnQ)                      !=     BN_num_bits(bnP))
+        
+190           {
+        
+191                    retVal        =  CRYPT_PARAMETER;                        //       problem           may       be  recoverable
+        
+192                    goto      Cleanup;
+        
+193           }
+        
+194     }
+        
+195     //   Get       compute       Phi     =  (p  -   1)(q     -    1)     =  pq    -   p     -  q    +     1   =   n  -  p  -  q  +  1
+        
+196     BN_copy(bnPhi,               bnN);
+        
+197     BN_sub(bnPhi,               bnPhi,      bnP);
+        
+198     BN_sub(bnPhi,               bnPhi,      bnQ);
+        
+199     BN_add_word(bnPhi,                   1);
+        
+200     //   Compute         the     multiplicative              inverse
+        
+201     BN_set_word(bnE,                exponent);
+        
+202     if(BN_mod_inverse(bnD,                      bnE,    bnPhi,        context)           ==    NULL)
+        
+203     {
 
      Family "2.0"                                                TCG Published                                                          Page 419
 
@@ -51227,411 +50999,411 @@ Level 00 Revision 01.16      Copyright 
       October 30, 2014                              Copyright © TCG 2006-2014                                 Level 00 Revision 01.16
       Part 4: Supporting Routines                                                                            Trusted Platform Module Library
 
-1058        return              CRYPT_FAIL;
-
-1059
-
-1060  //   Get      structures                 for     the   big    number    representations
-
-1061  context          =     BN_CTX_new();
-
-1062  if(context                ==   NULL)
-
-1063        FAIL(FATAL_ERROR_ALLOCATION);
-
-1064  BN_CTX_start(context);
-
-1065  bnP   =   BN_CTX_get(context);
-
-1066  bnQ   =   BN_CTX_get(context);
-
-1067  bnT   =   BN_CTX_get(context);
-
-1068  bnE   =   BN_CTX_get(context);
-
-1069  bnN   =   BN_CTX_get(context);
-
-1070  if(bnN        ==       NULL)
-
-1071        FAIL(FATAL_ERROR_INTERNAL);
-
-1072
-
-1073  //   Set      Q     to     zero.         This     is   used   as  a    flag.     The  prime      is  computed       in      P.  When  a
-
-1074  //   new      prime           is     found,       Q   is  checked      to  see   if   it    is   zero.      If   so,     P  is  copied
-
-1075  //   to   Q      and       a   new       P  is    found.      When     both   P  and    Q   are  non-zero,          the     modulus   and
-
-1076  //   private              exponent          are      computed     and   a  trial      encryption/decryption                 is
-
-1077  //   performed.                   If     the     encrypt/decrypt           fails,     assume     that   at     least     one    of   the
-
-1078  //   primes            is     composite.             Since    we  don't    know    which    one,     set    Q   to  zero        and  start
-
-1079  //   over        and       find       a     new   pair    of  primes.
-
-1080  BN_zero(bnQ);
-
-1081
-
-1082  //   Need        to       have       some     label
-
-1083  if(label            ==     NULL)
-
-1084        label            =   (const           char     *)&defaultLabel;
-
-1085  //   Get      the         label       size
-
-1086  for(lLen            =     0;   label[lLen++]              !=  0;);
-
-1087
-
-1088  //   Start          the       hash       using       the  seed    and   get   the     intermediate         hash     value
-
-1089  _cpri__StartHMAC(hashAlg,                              FALSE,     &h1,     seed->size,      seed->buffer,           &oPadKey.b);
-
-1090  _cpri__StartHash(hashAlg,                              FALSE,     &h2);
-
-1091  _cpri__UpdateHash(&h2,                            oPadKey.b.size,          oPadKey.b.buffer);
-
-1092
-
-1093  n->size          =     (keySizeInBits                 +7)/8;
-
-1094  pAssert(n->size                      <=     MAX_RSA_KEY_BYTES);
-
-1095  p->size          =     n->size           /  2;
-
-1096  if(e     ==      0)
-
-1097        e   =      RSA_DEFAULT_PUBLIC_EXPONENT;
-
-1098
-
-1099  BN_set_word(bnE,                      e);
-
-1100
-
-1101  //   The      first           test       will     increment       the   counter       from  zero.
-
-1102  for(outer              +=     1;     outer       !=   0;  outer++)
-
-1103  {
-
-1104        if(_plat__IsCanceled())
-
-1105        {
-
-1106                   retVal           =   CRYPT_CANCEL;
-
-1107                   goto         Cleanup;
-
-1108        }
-
-1109
-
-1110        //      Need         to     fill      in    the     candidate     with     the  hash
-
-1111        fill          =     digestSize;
-
-1112        pb      =     p->buffer;
-
-1113
-
-1114        //      Reset           the     inner       counter
-
-1115        inner            =   0;
-
-1116        for(i            =   p->size;           i   >   0;  i   -=  digestSize)
-
-1117        {
-
-1118                   inner++;
-
-1119                   //       Initialize             the   HMAC   with     saved     state
-
-1120                   _cpri__CopyHashState(&h,                         &h1);
-
-1121
-
-1122                   //       Hash       the    inner      counter    (the     one   that      changes     on   each    HMAC        iteration)
-
-1123                   UINT32_TO_BYTE_ARRAY(inner,                           swapped);
+1058           return              CRYPT_FAIL;
+         
+1059     
+         
+1060     //   Get      structures                 for     the   big    number    representations
+         
+1061     context          =     BN_CTX_new();
+         
+1062     if(context                ==   NULL)
+         
+1063           FAIL(FATAL_ERROR_ALLOCATION);
+         
+1064     BN_CTX_start(context);
+         
+1065     bnP   =   BN_CTX_get(context);
+         
+1066     bnQ   =   BN_CTX_get(context);
+         
+1067     bnT   =   BN_CTX_get(context);
+         
+1068     bnE   =   BN_CTX_get(context);
+         
+1069     bnN   =   BN_CTX_get(context);
+         
+1070     if(bnN        ==       NULL)
+         
+1071           FAIL(FATAL_ERROR_INTERNAL);
+         
+1072     
+         
+1073     //   Set      Q     to     zero.         This     is   used   as  a    flag.     The  prime      is  computed       in      P.  When  a
+         
+1074     //   new      prime           is     found,       Q   is  checked      to  see   if   it    is   zero.      If   so,     P  is  copied
+         
+1075     //   to   Q      and       a   new       P  is    found.      When     both   P  and    Q   are  non-zero,          the     modulus   and
+         
+1076     //   private              exponent          are      computed     and   a  trial      encryption/decryption                 is
+         
+1077     //   performed.                   If     the     encrypt/decrypt           fails,     assume     that   at     least     one    of   the
+         
+1078     //   primes            is     composite.             Since    we  don't    know    which    one,     set    Q   to  zero        and  start
+         
+1079     //   over        and       find       a     new   pair    of  primes.
+         
+1080     BN_zero(bnQ);
+         
+1081     
+         
+1082     //   Need        to       have       some     label
+         
+1083     if(label            ==     NULL)
+         
+1084           label            =   (const           char     *)&defaultLabel;
+         
+1085     //   Get      the         label       size
+         
+1086     for(lLen            =     0;   label[lLen++]              !=  0;);
+         
+1087     
+         
+1088     //   Start          the       hash       using       the  seed    and   get   the     intermediate         hash     value
+         
+1089     _cpri__StartHMAC(hashAlg,                              FALSE,     &h1,     seed->size,      seed->buffer,           &oPadKey.b);
+         
+1090     _cpri__StartHash(hashAlg,                              FALSE,     &h2);
+         
+1091     _cpri__UpdateHash(&h2,                            oPadKey.b.size,          oPadKey.b.buffer);
+         
+1092     
+         
+1093     n->size          =     (keySizeInBits                 +7)/8;
+         
+1094     pAssert(n->size                      <=     MAX_RSA_KEY_BYTES);
+         
+1095     p->size          =     n->size           /  2;
+         
+1096     if(e     ==      0)
+         
+1097           e   =      RSA_DEFAULT_PUBLIC_EXPONENT;
+         
+1098     
+         
+1099     BN_set_word(bnE,                      e);
+         
+1100     
+         
+1101     //   The      first           test       will     increment       the   counter       from  zero.
+         
+1102     for(outer              +=     1;     outer       !=   0;  outer++)
+         
+1103     {
+         
+1104           if(_plat__IsCanceled())
+         
+1105           {
+         
+1106                      retVal           =   CRYPT_CANCEL;
+         
+1107                      goto         Cleanup;
+         
+1108           }
+         
+1109     
+         
+1110           //      Need         to     fill      in    the     candidate     with     the  hash
+         
+1111           fill          =     digestSize;
+         
+1112           pb      =     p->buffer;
+         
+1113     
+         
+1114           //      Reset           the     inner       counter
+         
+1115           inner            =   0;
+         
+1116           for(i            =   p->size;           i   >   0;  i   -=  digestSize)
+         
+1117           {
+         
+1118                      inner++;
+         
+1119                      //       Initialize             the   HMAC   with     saved     state
+         
+1120                      _cpri__CopyHashState(&h,                         &h1);
+         
+1121     
+         
+1122                      //       Hash       the    inner      counter    (the     one   that      changes     on   each    HMAC        iteration)
+         
+1123                      UINT32_TO_BYTE_ARRAY(inner,                           swapped);
 
       Family "2.0"                                                      TCG Published                                                       Page 437
 
       Level 00 Revision 01.16                                Copyright © TCG 2006-2014                                            October 30, 2014
       Trusted Platform Module Library                                                                             Part 4: Supporting Routines
 
-1124            _cpri__UpdateHash(&h,                        4,     swapped);
-
-1125            _cpri__UpdateHash(&h,                        lLen,         (BYTE      *)label);
-
-1126
-
-1127            //      Is     there   any       party       1   data
-
-1128            if(extra           !=  NULL)
-
-1129                    _cpri__UpdateHash(&h,                          extra->size,         extra->buffer);
-
-1130
-
-1131            //      Include        the      outer     counter          (the       one   that    changes       on  each  prime
-
-1132            //      prime      candidate          generation
-
-1133            UINT32_TO_BYTE_ARRAY(outer,                                swapped);
-
-1134            _cpri__UpdateHash(&h,                        4,     swapped);
-
-1135            _cpri__UpdateHash(&h,                        2,     (BYTE      *)&keySizeInBits);
-
-1136            if(i        <  fill)
-
-1137                    fill       =   i;
-
-1138            _cpri__CompleteHash(&h,                          fill,         pb);
-
-1139
-
-1140            //      Restart        the      oPad   hash
-
-1141            _cpri__CopyHashState(&h,                            &h2);
-
-1142
-
-1143            //      Add    the     last      hashed         data
-
-1144            _cpri__UpdateHash(&h,                        fill,         pb);
-
-1145
-
-1146            //      gives      a   completed          HMAC
-
-1147            _cpri__CompleteHash(&h,                          fill,         pb);
-
-1148            pb      +=     fill;
-
-1149  }
-
-1150  //        Set     the    Most    significant               2     bits    and     the  low     bit  of  the      candidate
-
-1151  p->buffer[0]                 |=  0xC0;
-
-1152  p->buffer[p->size                      -   1]   |=     1;
-
-1153
-
-1154  //        Convert        the     candidate          to     a     BN
-
-1155  BN_bin2bn(p->buffer,                        p->size,             bnP);
-
-1156
-
-1157  //        If   this      is      the   second       prime,           make    sure     that    it   differs      from  the
-
-1158  //        first       prime      by    at   least         2^100
-
-1159  if(!BN_is_zero(bnQ))
-
-1160  {
-
-1161            //      bnQ    is      non-zero       if     we     already        found    it
-
-1162            if(BN_ucmp(bnP,                  bnQ)     <     0)
-
-1163                    BN_sub(bnT,              bnQ,     bnP);
-
-1164            else
-
-1165                    BN_sub(bnT,              bnP,     bnQ);
-
-1166            if(BN_num_bits(bnT)                    <     100)          //  Difference         has    to  be   at  least      100  bits
-
-1167                    continue;
-
-1168  }
-
-1169  //        Make    sure       that      the     prime       candidate            (p)   is  not     divisible     by    the  exponent
-
-1170  //        and     that       (p-1)     is   not     divisible            by     the   exponent
-
-1171  //        Get     the    remainder          after         dividing          by   the  modulus
-
-1172  rem       =    BN_mod_word(bnP,                 e);
-
-1173  if(rem            ==     0)  //  evenly         divisible            so     add  two      keeping      the  number    odd  and
-
-1174            //      making         sure     that   1     !=     p  mod     e
-
-1175            BN_add_word(bnP,                  2);
-
-1176  else          if(rem         ==  1)    //   leaves         a     remainder       of   1   so   subtract         two  keeping    the
-
-1177            //      number         odd   and     making         (e-1)      =   p   mod  e
-
-1178            BN_sub_word(bnP,                  2);
-
-1179
-
-1180  //        Have    a      candidate,         check         for    primality
-
-1181  if((retVal               =   (CRYPT_RESULT)BN_is_prime_ex(bnP,
-
-1182                               BN_prime_checks,                    NULL,      NULL))    <   0)
-
-1183            FAIL(FATAL_ERROR_INTERNAL);
-
-1184
-
-1185  if(retVal                !=  1)
-
-1186            continue;
-
-1187
-
-1188  //        Found       a  prime,        is   this       the       first      or   second.
-
-1189  if(BN_is_zero(bnQ))
+1124               _cpri__UpdateHash(&h,                        4,     swapped);
+         
+1125               _cpri__UpdateHash(&h,                        lLen,         (BYTE      *)label);
+         
+1126     
+         
+1127               //      Is     there   any       party       1   data
+         
+1128               if(extra           !=  NULL)
+         
+1129                       _cpri__UpdateHash(&h,                          extra->size,         extra->buffer);
+         
+1130     
+         
+1131               //      Include        the      outer     counter          (the       one   that    changes       on  each  prime
+         
+1132               //      prime      candidate          generation
+         
+1133               UINT32_TO_BYTE_ARRAY(outer,                                swapped);
+         
+1134               _cpri__UpdateHash(&h,                        4,     swapped);
+         
+1135               _cpri__UpdateHash(&h,                        2,     (BYTE      *)&keySizeInBits);
+         
+1136               if(i        <  fill)
+         
+1137                       fill       =   i;
+         
+1138               _cpri__CompleteHash(&h,                          fill,         pb);
+         
+1139     
+         
+1140               //      Restart        the      oPad   hash
+         
+1141               _cpri__CopyHashState(&h,                            &h2);
+         
+1142     
+         
+1143               //      Add    the     last      hashed         data
+         
+1144               _cpri__UpdateHash(&h,                        fill,         pb);
+         
+1145     
+         
+1146               //      gives      a   completed          HMAC
+         
+1147               _cpri__CompleteHash(&h,                          fill,         pb);
+         
+1148               pb      +=     fill;
+         
+1149     }
+         
+1150     //        Set     the    Most    significant               2     bits    and     the  low     bit  of  the      candidate
+         
+1151     p->buffer[0]                 |=  0xC0;
+         
+1152     p->buffer[p->size                      -   1]   |=     1;
+         
+1153     
+         
+1154     //        Convert        the     candidate          to     a     BN
+         
+1155     BN_bin2bn(p->buffer,                        p->size,             bnP);
+         
+1156     
+         
+1157     //        If   this      is      the   second       prime,           make    sure     that    it   differs      from  the
+         
+1158     //        first       prime      by    at   least         2^100
+         
+1159     if(!BN_is_zero(bnQ))
+         
+1160     {
+         
+1161               //      bnQ    is      non-zero       if     we     already        found    it
+         
+1162               if(BN_ucmp(bnP,                  bnQ)     <     0)
+         
+1163                       BN_sub(bnT,              bnQ,     bnP);
+         
+1164               else
+         
+1165                       BN_sub(bnT,              bnP,     bnQ);
+         
+1166               if(BN_num_bits(bnT)                    <     100)          //  Difference         has    to  be   at  least      100  bits
+         
+1167                       continue;
+         
+1168     }
+         
+1169     //        Make    sure       that      the     prime       candidate            (p)   is  not     divisible     by    the  exponent
+         
+1170     //        and     that       (p-1)     is   not     divisible            by     the   exponent
+         
+1171     //        Get     the    remainder          after         dividing          by   the  modulus
+         
+1172     rem       =    BN_mod_word(bnP,                 e);
+         
+1173     if(rem            ==     0)  //  evenly         divisible            so     add  two      keeping      the  number    odd  and
+         
+1174               //      making         sure     that   1     !=     p  mod     e
+         
+1175               BN_add_word(bnP,                  2);
+         
+1176     else          if(rem         ==  1)    //   leaves         a     remainder       of   1   so   subtract         two  keeping    the
+         
+1177               //      number         odd   and     making         (e-1)      =   p   mod  e
+         
+1178               BN_sub_word(bnP,                  2);
+         
+1179     
+         
+1180     //        Have    a      candidate,         check         for    primality
+         
+1181     if((retVal               =   (CRYPT_RESULT)BN_is_prime_ex(bnP,
+         
+1182                                  BN_prime_checks,                    NULL,      NULL))    <   0)
+         
+1183               FAIL(FATAL_ERROR_INTERNAL);
+         
+1184     
+         
+1185     if(retVal                !=  1)
+         
+1186               continue;
+         
+1187     
+         
+1188     //        Found       a  prime,        is   this       the       first      or   second.
+         
+1189     if(BN_is_zero(bnQ))
 
       Page 438                                                   TCG Published                                                        Family "2.0"
 
       October 30, 2014                               Copyright © TCG 2006-2014                                        Level 00 Revision 01.16
       Part 4: Supporting Routines                                                                                               Trusted Platform Module Library
 
-1190  {
-
-1191                //    copy     p     to    q   and          compute           another           prime          in   p
-
-1192                BN_copy(bnQ,               bnP);
-
-1193                continue;
-
-1194  }
-
-1195  //Form              the   public             modulus
-
-1196  BN_mul(bnN,                  bnP,        bnQ,          context);
-
-1197  if(BN_num_bits(bnN)                              !=       keySizeInBits)
-
-1198                FAIL(FATAL_ERROR_INTERNAL);
-
-1199
-
-1200  //            Save  the      public          modulus
-
-1201  BnTo2B(n,                bnN,         n->size);                  //     Will         pad   the      buffer           to   the   correct      size
-
-1202  pAssert((n->buffer[0]                                  &     0x80)         !=     0);
-
-1203
-
-1204  //            And   one   prime
-
-1205  BnTo2B(p,                bnP,         p->size);
-
-1206  pAssert((p->buffer[0]                                  &     0x80)         !=     0);
-
-1207
-
-1208  //            Finish     by     making           sure         that         we     can      form     the       modular         inverse    of  PHI
-
-1209  //            with  respect              to  the          public           exponent
-
-1210  //            Compute     PHI         =  (p      -     1)(q         -   1)     =     n  -  p  -     q     +   1
-
-1211  //            Make  sure        that         we     can       form         the       modular        inverse
-
-1212  BN_sub(bnT,                  bnN,        bnP);
-
-1213  BN_sub(bnT,                  bnT,        bnQ);
-
-1214  BN_add_word(bnT,                         1);
-
-1215
-
-1216  //            find  d    such         that       (Phi         *     d)     mod       e  ==1
-
-1217  //            If   there     isn't           then         we     are       broken          because           we   took     the     step
-
-1218  //            of   making       sure         that         the       prime         !=    1  mod      e     so     the     modular   inverse
-
-1219  //            must  exist
-
-1220  if(BN_mod_inverse(bnT,                                    bnE,         bnT,       context)          ==       NULL     ||   BN_is_zero(bnT))
-
-1221                FAIL(FATAL_ERROR_INTERNAL);
-
-1222
-
-1223  //            And,  finally,             do      a     trial           encryption             decryption
-
-1224  {
-
-1225                TPM2B_TYPE(RSA_KEY,                            MAX_RSA_KEY_BYTES);
-
-1226                TPM2B_RSA_KEY                                   r;
-
-1227                r.t.size          =     sizeof(n->size);
-
-1228
-
-1229                //    If   we     are      using            a   seed,         then        results           must       be   reproducible       on    each
-
-1230                //    call.       Otherwise,                   just       get       a     random      number
-
-1231                if(seed        ==       NULL)
-
-1232                      _cpri__GenerateRandom(n->size,                                            r.t.buffer);
-
-1233                else
-
-1234                {
-
-1235                      //    this           this       version             does         not   have        a     deterministic         RNG,      XOR   the
-
-1236                      //    public             key       and       private             exponent          to     get     a   deterministic      value
-
-1237                      //    for         testing.
-
-1238                      int                          i;
-
-1239
-
-1240                      //    Generate               a     random-ish                 number      starting               with     the  public    modulus
-
-1241                      //    XORed          with          the       MSO       of     the      seed
-
-1242                      for(i          =     0;  i      <     n->size;             i++)
-
-1243                               r.t.buffer[i]                       =     n->buffer[i]              ^     seed->buffer[0];
-
-1244                }
-
-1245                //    Make     sure        that          the       number           is    smaller           than       the   public  modulus
-
-1246                r.t.buffer[0]                  &=     0x7F;
-
-1247                           //     Convert
-
-1248                if(        BN_bin2bn(r.t.buffer,                                 r.t.size,            bnP)         ==   NULL
-
-1249                           //     Encrypt             with         the       public          exponent
-
-1250                      ||   BN_mod_exp(bnQ,                         bnP,       bnE,        bnN,     context)             !=   1
-
-1251                           //     Decrypt             with         the       private         exponent
-
-1252                      ||   BN_mod_exp(bnQ,                         bnQ,       bnT,        bnN,     context)             !=   1)
-
-1253                      FAIL(FATAL_ERROR_INTERNAL);
-
-1254                //    If   the       starting               and       ending           values      are         not     the   same,   start     over  )-;
-
-1255                if(BN_ucmp(bnP,                    bnQ)         !=       0)
+1190     {
+         
+1191                   //    copy     p     to    q   and          compute           another           prime          in   p
+         
+1192                   BN_copy(bnQ,               bnP);
+         
+1193                   continue;
+         
+1194     }
+         
+1195     //Form              the   public             modulus
+         
+1196     BN_mul(bnN,                  bnP,        bnQ,          context);
+         
+1197     if(BN_num_bits(bnN)                              !=       keySizeInBits)
+         
+1198                   FAIL(FATAL_ERROR_INTERNAL);
+         
+1199     
+         
+1200     //            Save  the      public          modulus
+         
+1201     BnTo2B(n,                bnN,         n->size);                  //     Will         pad   the      buffer           to   the   correct      size
+         
+1202     pAssert((n->buffer[0]                                  &     0x80)         !=     0);
+         
+1203     
+         
+1204     //            And   one   prime
+         
+1205     BnTo2B(p,                bnP,         p->size);
+         
+1206     pAssert((p->buffer[0]                                  &     0x80)         !=     0);
+         
+1207     
+         
+1208     //            Finish     by     making           sure         that         we     can      form     the       modular         inverse    of  PHI
+         
+1209     //            with  respect              to  the          public           exponent
+         
+1210     //            Compute     PHI         =  (p      -     1)(q         -   1)     =     n  -  p  -     q     +   1
+         
+1211     //            Make  sure        that         we     can       form         the       modular        inverse
+         
+1212     BN_sub(bnT,                  bnN,        bnP);
+         
+1213     BN_sub(bnT,                  bnT,        bnQ);
+         
+1214     BN_add_word(bnT,                         1);
+         
+1215     
+         
+1216     //            find  d    such         that       (Phi         *     d)     mod       e  ==1
+         
+1217     //            If   there     isn't           then         we     are       broken          because           we   took     the     step
+         
+1218     //            of   making       sure         that         the       prime         !=    1  mod      e     so     the     modular   inverse
+         
+1219     //            must  exist
+         
+1220     if(BN_mod_inverse(bnT,                                    bnE,         bnT,       context)          ==       NULL     ||   BN_is_zero(bnT))
+         
+1221                   FAIL(FATAL_ERROR_INTERNAL);
+         
+1222     
+         
+1223     //            And,  finally,             do      a     trial           encryption             decryption
+         
+1224     {
+         
+1225                   TPM2B_TYPE(RSA_KEY,                            MAX_RSA_KEY_BYTES);
+         
+1226                   TPM2B_RSA_KEY                                   r;
+         
+1227                   r.t.size          =     sizeof(n->size);
+         
+1228     
+         
+1229                   //    If   we     are      using            a   seed,         then        results           must       be   reproducible       on    each
+         
+1230                   //    call.       Otherwise,                   just       get       a     random      number
+         
+1231                   if(seed        ==       NULL)
+         
+1232                         _cpri__GenerateRandom(n->size,                                            r.t.buffer);
+         
+1233                   else
+         
+1234                   {
+         
+1235                         //    this           this       version             does         not   have        a     deterministic         RNG,      XOR   the
+         
+1236                         //    public             key       and       private             exponent          to     get     a   deterministic      value
+         
+1237                         //    for         testing.
+         
+1238                         int                          i;
+         
+1239     
+         
+1240                         //    Generate               a     random-ish                 number      starting               with     the  public    modulus
+         
+1241                         //    XORed          with          the       MSO       of     the      seed
+         
+1242                         for(i          =     0;  i      <     n->size;             i++)
+         
+1243                                  r.t.buffer[i]                       =     n->buffer[i]              ^     seed->buffer[0];
+         
+1244                   }
+         
+1245                   //    Make     sure        that          the       number           is    smaller           than       the   public  modulus
+         
+1246                   r.t.buffer[0]                  &=     0x7F;
+         
+1247                              //     Convert
+         
+1248                   if(        BN_bin2bn(r.t.buffer,                                 r.t.size,            bnP)         ==   NULL
+         
+1249                              //     Encrypt             with         the       public          exponent
+         
+1250                         ||   BN_mod_exp(bnQ,                         bnP,       bnE,        bnN,     context)             !=   1
+         
+1251                              //     Decrypt             with         the       private         exponent
+         
+1252                         ||   BN_mod_exp(bnQ,                         bnQ,       bnT,        bnN,     context)             !=   1)
+         
+1253                         FAIL(FATAL_ERROR_INTERNAL);
+         
+1254                   //    If   the       starting               and       ending           values      are         not     the   same,   start     over  )-;
+         
+1255                   if(BN_ucmp(bnP,                    bnQ)         !=       0)
 
       Family "2.0"                                                           TCG Published                                                               Page 439
 
@@ -57322,11 +57094,11 @@ Level 00 Revision 01.16      Copyright 
      Level 00 Revision 01.16                                      Copyright © TCG 2006-2014                                                     October 30, 2014
      Trusted Platform Module Library                                                                                      Part 4: Supporting Routines
 
-423  //  If        B     is   provided,               compute         K=[d]B       and    L=[r]B
+423     //  If        B     is   provided,               compute         K=[d]B       and    L=[r]B
 
-424  if(B         !=     NULL)
+424     if(B         !=     NULL)
 
-425  {
+425     {
 
 426            //     Allocate           the         points      to      receive      the      value
 
@@ -57382,11 +57154,11 @@ Level 00 Revision 01.16      Copyright 
 
 452            Point2B(group,                     L,     pL,     (INT16)keySizeInBytes,                   context);
 
-453  }
+453     }
 
-454  if(M         !=     NULL     ||     B     ==     NULL)
+454     if(M         !=     NULL     ||     B     ==     NULL)
 
-455  {
+455     {
 
 456            //     if     this     is       the       third   point        multiply,        check         for  cancel      first
 
@@ -57438,21 +57210,21 @@ Level 00 Revision 01.16      Copyright 
 
 480                      Point2B(group,                   E,     pE,     (INT16)keySizeInBytes,                   context);
 
-481  }
+481     }
 
 482  Cleanup:
 
-483  EC_GROUP_free(group);
+483     EC_GROUP_free(group);
 
-484  if(pK         !=     NULL)       EC_POINT_free(pK);
+484     if(pK         !=     NULL)       EC_POINT_free(pK);
 
-485  if(pL         !=     NULL)       EC_POINT_free(pL);
+485     if(pL         !=     NULL)       EC_POINT_free(pL);
 
-486  if(pE         !=     NULL)       EC_POINT_free(pE);
+486     if(pE         !=     NULL)       EC_POINT_free(pE);
 
-487  if(pM         !=     NULL)       EC_POINT_free(pM);
+487     if(pM         !=     NULL)       EC_POINT_free(pM);
 
-488  if(pB         !=     NULL)       EC_POINT_free(pB);
+488     if(pB         !=     NULL)       EC_POINT_free(pB);
 
      Page 488                                                             TCG Published                                                      Family "2.0"
 
@@ -57695,137 +57467,137 @@ Level 00 Revision 01.16      Copyright 
      October 30, 2014                      Copyright © TCG 2006-2014                                             Level 00 Revision 01.16
      Part 4: Supporting Routines                                                                          Trusted Platform Module Library
 
-585  pAssert(                seed   !=   NULL     &&     dOut       !=     NULL  &&    Qout    !=  NULL   &&  curveData        !=     NULL);
-
-586
-
-587  //   Non-fatal              parameter       checks.
-
-588  if(hLen          <=     0)
-
-589       return             CRYPT_PARAMETER;
-
-590
-
-591  //   allocate            the   local     BN     values
-
-592  context          =   BN_CTX_new();
-
-593  if(context              ==   NULL)
-
-594       FAIL(FATAL_ERROR_ALLOCATION);
-
-595  BN_CTX_start(context);
-
-596  bnNm1     =      BN_CTX_get(context);
-
-597  bnD  =    BN_CTX_get(context);
-
-598
-
-599  //   The      size       of   the   input       scalars           is   limited       by  the  size   of  the   size     of    a
-
-600  //   TPM2B_ECC_PARAMETER.                    Make       sure       that     it   is  not     irrational.
-
-601  pAssert((int)                curveData->n->size                   <=   MAX_ECC_KEY_BYTES);
-
-602
-
-603  if(       bnD        ==     NULL
-
-604       ||   BN_bin2bn(curveData->n->buffer,                                curveData->n->size,             bnNm1)     ==  NULL
-
-605       ||   (keySizeInBytes                =   (INT16)           BN_num_bytes(bnNm1))           >      MAX_ECC_KEY_BYTES)
-
-606       FAIL(FATAL_ERROR_INTERNAL);
-
-607
-
-608  //   get      the       total     number     of     bits
-
-609  totalBits            =   BN_num_bits(bnNm1)                 +     64;
-
-610
-
-611  //   Reduce          bnNm1     from     'n'     to  'n'        -   1
-
-612  BN_sub_word(bnNm1,                  1);
-
-613
-
-614  //   Initialize              the   count     value
-
-615  if(counter              !=   NULL)
-
-616       count           =   *counter;
-
-617  if(count            ==   0)
-
-618       count           =   1;
-
-619
-
-620  //   Start          search     for     key   (should           be     quick)
-
-621  for(;     count          !=   0;   count++)
-
-622  {
-
-623
-
-624       UINT32_TO_BYTE_ARRAY(count,                               marshaledCounter.t.buffer);
-
-625       _cpri__KDFa(hashAlg,                       seed,       label,       extra,      &marshaledCounter.b,
-
-626                                 totalBits,           withExtra,           NULL,       FALSE);
-
-627
-
-628       //       Convert         the   result       and    modular          reduce
-
-629       //       Assume         the   size     variables             do   not  overflow,         which  should    not      happen   in
-
-630       //       the       contexts       that     this    function            will     be  called.
-
-631       pAssert(keySizeInBytes                         <=  MAX_ECC_KEY_BYTES);
-
-632       if       (         BN_bin2bn(withExtra,                   keySizeInBytes+8,              bnD)   ==  NULL
-
-633                   ||     BN_mod(bnD,         bnD,    bnNm1,            context)       !=  1)
-
-634                   FAIL(FATAL_ERROR_INTERNAL);
-
-635
-
-636       //       Add       one   to   get   0   <   d  <   n
-
-637       BN_add_word(bnD,                   1);
-
-638       if(BnTo2B(&dOut->b,                     bnD,       keySizeInBytes)              !=   1)
-
-639                           FAIL(FATAL_ERROR_INTERNAL);
-
-640
-
-641       //       Do     the     point     multiply         to     create       the   public      portion    of  the    key.    If
-
-642       //       the       multiply       generates        the        point    at    infinity    (unlikely),         do    another
-
-643       //       iteration.
-
-644       if(                (retVal     =   _cpri__EccPointMultiply(Qout,                         curveId,       dOut,    NULL,      NULL))
-
-645                   !=     CRYPT_NO_RESULT)
-
-646                   break;
-
-647  }
-
-648
-
-649  if(count            ==   0)   //   if   counter         wrapped,         then     the    TPM  should     go  into     failure    mode
-
-650       FAIL(FATAL_ERROR_INTERNAL);
+585     pAssert(                seed   !=   NULL     &&     dOut       !=     NULL  &&    Qout    !=  NULL   &&  curveData        !=     NULL);
+        
+586     
+        
+587     //   Non-fatal              parameter       checks.
+        
+588     if(hLen          <=     0)
+        
+589          return             CRYPT_PARAMETER;
+        
+590     
+        
+591     //   allocate            the   local     BN     values
+        
+592     context          =   BN_CTX_new();
+        
+593     if(context              ==   NULL)
+        
+594          FAIL(FATAL_ERROR_ALLOCATION);
+        
+595     BN_CTX_start(context);
+        
+596     bnNm1     =      BN_CTX_get(context);
+        
+597     bnD  =    BN_CTX_get(context);
+        
+598     
+        
+599     //   The      size       of   the   input       scalars           is   limited       by  the  size   of  the   size     of    a
+        
+600     //   TPM2B_ECC_PARAMETER.                    Make       sure       that     it   is  not     irrational.
+        
+601     pAssert((int)                curveData->n->size                   <=   MAX_ECC_KEY_BYTES);
+        
+602     
+        
+603     if(       bnD        ==     NULL
+        
+604          ||   BN_bin2bn(curveData->n->buffer,                                curveData->n->size,             bnNm1)     ==  NULL
+        
+605          ||   (keySizeInBytes                =   (INT16)           BN_num_bytes(bnNm1))           >      MAX_ECC_KEY_BYTES)
+        
+606          FAIL(FATAL_ERROR_INTERNAL);
+        
+607     
+        
+608     //   get      the       total     number     of     bits
+        
+609     totalBits            =   BN_num_bits(bnNm1)                 +     64;
+        
+610     
+        
+611     //   Reduce          bnNm1     from     'n'     to  'n'        -   1
+        
+612     BN_sub_word(bnNm1,                  1);
+        
+613     
+        
+614     //   Initialize              the   count     value
+        
+615     if(counter              !=   NULL)
+        
+616          count           =   *counter;
+        
+617     if(count            ==   0)
+        
+618          count           =   1;
+        
+619     
+        
+620     //   Start          search     for     key   (should           be     quick)
+        
+621     for(;     count          !=   0;   count++)
+        
+622     {
+        
+623     
+        
+624          UINT32_TO_BYTE_ARRAY(count,                               marshaledCounter.t.buffer);
+        
+625          _cpri__KDFa(hashAlg,                       seed,       label,       extra,      &marshaledCounter.b,
+        
+626                                    totalBits,           withExtra,           NULL,       FALSE);
+        
+627     
+        
+628          //       Convert         the   result       and    modular          reduce
+        
+629          //       Assume         the   size     variables             do   not  overflow,         which  should    not      happen   in
+        
+630          //       the       contexts       that     this    function            will     be  called.
+        
+631          pAssert(keySizeInBytes                         <=  MAX_ECC_KEY_BYTES);
+        
+632          if       (         BN_bin2bn(withExtra,                   keySizeInBytes+8,              bnD)   ==  NULL
+        
+633                      ||     BN_mod(bnD,         bnD,    bnNm1,            context)       !=  1)
+        
+634                      FAIL(FATAL_ERROR_INTERNAL);
+        
+635     
+        
+636          //       Add       one   to   get   0   <   d  <   n
+        
+637          BN_add_word(bnD,                   1);
+        
+638          if(BnTo2B(&dOut->b,                     bnD,       keySizeInBytes)              !=   1)
+        
+639                              FAIL(FATAL_ERROR_INTERNAL);
+        
+640     
+        
+641          //       Do     the     point     multiply         to     create       the   public      portion    of  the    key.    If
+        
+642          //       the       multiply       generates        the        point    at    infinity    (unlikely),         do    another
+        
+643          //       iteration.
+        
+644          if(                (retVal     =   _cpri__EccPointMultiply(Qout,                         curveId,       dOut,    NULL,      NULL))
+        
+645                      !=     CRYPT_NO_RESULT)
+        
+646                      break;
+        
+647     }
+        
+648     
+        
+649     if(count            ==   0)   //   if   counter         wrapped,         then     the    TPM  should     go  into     failure    mode
+        
+650          FAIL(FATAL_ERROR_INTERNAL);
 
      Family "2.0"                                                   TCG Published                                                     Page 491
 
@@ -58112,111 +57884,111 @@ Level 00 Revision 01.16      Copyright 
 
 779                       break;
 
-780  }
-
-781
-
-782  //        Set     z     =     leftmost                 bits      of    the     digest
-
-783  //        NOTE:         This           is     implemented              such        that     the     key  size       needs   to  be
-
-784  //                      an       even         number             of  bytes      in     length.
-
-785  if(digest->size                            >     curveData->n->size)
-
-786  {
-
-787            //      Assume               the       size         variables         do     not   overflow,          which      should    not  happen
-
-788            //      in       the         contexts               that     this     function         will    be     called.
-
-789            pAssert(curveData->n->size                                        <=     MAX_ECC_KEY_BYTES);
-
-790            //      digest               is     larger             than  n    so     truncate
-
-791            BN_bin2bn(digest->buffer,                                        curveData->n->size,                  bnZ);
-
-792  }
-
-793  else
-
-794  {
-
-795            //      Assume               the       size         variables         do     not   overflow,          which      should    not  happen
-
-796            //      in       the         contexts               that     this     function         will    be     called.
-
-797            pAssert(digest->size                                   <=    MAX_DIGEST_SIZE);
-
-798            //      digest               is     same         or    smaller        than     n   so     use  it     all
-
-799            BN_bin2bn(digest->buffer,                                        digest->size,            bnZ);
-
-800  }
-
-801
-
-802  //        Assume           the         size         variables          do      not     overflow,         which      should    not    happen  in
-
-803  //        the     contexts                 that        this          function       will     be     called.
-
-804  assert2Bsize(dIn->t);
-
-805  if(            bnZ         ==       NULL
-
-806
-
-807            //   need           the         private             scalar       of   the    signing      key
-
-808            ||   BN_bin2bn(dIn->t.buffer,                                     dIn->t.size,            bnD)      ==    NULL)
-
-809            FAIL(FATAL_ERROR_INTERNAL);
-
-810
-
-811  //        NOTE:         When           the       result          of    an   operation         is    going       to     be  reduced   mod  x
-
-812  //        any     modular                 multiplication                   is   done     so   that       the    intermediate         values
-
-813  //        don't         get         too       large.
-
-814  //
-
-815  //        now     have           inverse               of     K  (bnIk),        z   (bnZ),       r  (bnR),          d  (bnD)    and  n    (bnN)
-
-816  //        Compute             s     =     k^-1         (z     +  r*d)(mod          n)
-
-817            //         first             do     d     =  r*d       mod   n
-
-818  if(           !BN_mod_mul(bnD,                             bnR,      bnD,      bnN,    context)
+780            }
+               
+781            
+               
+782            //        Set     z     =     leftmost                 bits      of    the     digest
+               
+783            //        NOTE:         This           is     implemented              such        that     the     key  size       needs   to  be
+               
+784            //                      an       even         number             of  bytes      in     length.
+               
+785            if(digest->size                            >     curveData->n->size)
+               
+786            {
+               
+787                      //      Assume               the       size         variables         do     not   overflow,          which      should    not  happen
+               
+788                      //      in       the         contexts               that     this     function         will    be     called.
+               
+789                      pAssert(curveData->n->size                                        <=     MAX_ECC_KEY_BYTES);
+               
+790                      //      digest               is     larger             than  n    so     truncate
+               
+791                      BN_bin2bn(digest->buffer,                                        curveData->n->size,                  bnZ);
+               
+792            }
+               
+793            else
+               
+794            {
+               
+795                      //      Assume               the       size         variables         do     not   overflow,          which      should    not  happen
+               
+796                      //      in       the         contexts               that     this     function         will    be     called.
+               
+797                      pAssert(digest->size                                   <=    MAX_DIGEST_SIZE);
+               
+798                      //      digest               is     same         or    smaller        than     n   so     use  it     all
+               
+799                      BN_bin2bn(digest->buffer,                                        digest->size,            bnZ);
+               
+800            }
+               
+801            
+               
+802            //        Assume           the         size         variables          do      not     overflow,         which      should    not    happen  in
+               
+803            //        the     contexts                 that        this          function       will     be     called.
+               
+804            assert2Bsize(dIn->t);
+               
+805            if(            bnZ         ==       NULL
+               
+806            
+               
+807                      //   need           the         private             scalar       of   the    signing      key
+               
+808                      ||   BN_bin2bn(dIn->t.buffer,                                     dIn->t.size,            bnD)      ==    NULL)
+               
+809                      FAIL(FATAL_ERROR_INTERNAL);
+               
+810            
+               
+811            //        NOTE:         When           the       result          of    an   operation         is    going       to     be  reduced   mod  x
+               
+812            //        any     modular                 multiplication                   is   done     so   that       the    intermediate         values
+               
+813            //        don't         get         too       large.
+               
+814            //
+               
+815            //        now     have           inverse               of     K  (bnIk),        z   (bnZ),       r  (bnR),          d  (bnD)    and  n    (bnN)
+               
+816            //        Compute             s     =     k^-1         (z     +  r*d)(mod          n)
+               
+817                      //         first             do     d     =  r*d       mod   n
+               
+818            if(           !BN_mod_mul(bnD,                             bnR,      bnD,      bnN,    context)
 
 819
 
-820            //   d     =     z     +     r   *     d
-
-821            ||   !BN_add(bnD,                         bnZ,         bnD)
-
-822
-
-823            //   d     =     k^(-1)(z                 +  r      *  d)(mod        n)
-
-824            ||   !BN_mod_mul(bnD,                               bnIk,    bnD,        bnN,     context)
-
-825
-
-826            //   convert                 to     TPM2B           format
-
-827            ||   !BnTo2B(&sOut->b,                                 bnD,  curveData->n->size)
-
-828
-
-829            //   and         write           the         modular         reduced         version      of   r
-
-830            //   NOTE:             this         was      deferred            to   reduce       the    number        of
-
-831            //   error             checks.
-
-832            ||   !BnTo2B(&rOut->b,                                 bnR,  curveData->n->size))
+820                      //   d     =     z     +     r   *     d
+                         
+821                      ||   !BN_add(bnD,                         bnZ,         bnD)
+                         
+822                      
+                         
+823                      //   d     =     k^(-1)(z                 +  r      *  d)(mod        n)
+                         
+824                      ||   !BN_mod_mul(bnD,                               bnIk,    bnD,        bnN,     context)
+                         
+825                      
+                         
+826                      //   convert                 to     TPM2B           format
+                         
+827                      ||   !BnTo2B(&sOut->b,                                 bnD,  curveData->n->size)
+                         
+828                      
+                         
+829                      //   and         write           the         modular         reduced         version      of   r
+                         
+830                      //   NOTE:             this         was      deferred            to   reduce       the    number        of
+                         
+831                      //   error             checks.
+                         
+832                      ||   !BnTo2B(&rOut->b,                                 bnR,  curveData->n->size))
 
      Page 494                                                               TCG Published                                                      Family "2.0"
 
